import "@tamagui/polyfill-dev";
import { Adapt, AdaptParent, AdaptPortalContents, useAdaptIsActive } from "@tamagui/adapt";
import { Animate } from "@tamagui/animate";
import { ResetPresence } from "@tamagui/animate-presence";
import { hideOthers } from "@tamagui/aria-hidden";
import { useComposedRefs } from "@tamagui/compose-refs";
import { isWeb } from "@tamagui/constants";
import { Stack, Theme, View, createShallowSetState, createStyledContext, useEvent, useGet, useThemeName } from "@tamagui/core";
import { FloatingOverrideContext } from "@tamagui/floating";
import { FocusScope } from "@tamagui/focus-scope";
import { composeEventHandlers, withStaticProperties } from "@tamagui/helpers";
import { Popper, PopperAnchor, PopperArrow, PopperContent, PopperContentFrame, PopperContext, usePopperContext } from "@tamagui/popper";
import { Portal } from "@tamagui/portal";
import { RemoveScroll } from "@tamagui/remove-scroll";
import { Sheet, SheetController } from "@tamagui/sheet";
import { YStack } from "@tamagui/stacks";
import { useControllableState } from "@tamagui/use-controllable-state";
import * as React from "react";
import { Platform, ScrollView } from "react-native-web";
import { useFloatingContext } from "./useFloatingContext.mjs";
import { Fragment, jsx, jsxs } from "react/jsx-runtime";
const POPOVER_SCOPE = "PopoverScope",
  PopoverContext = createStyledContext({}),
  usePopoverContext = PopoverContext.useStyledContext,
  PopoverAnchor = React.forwardRef(function (props, forwardedRef) {
    const {
        __scopePopover,
        ...rest
      } = props,
      context = usePopoverContext(__scopePopover),
      {
        onCustomAnchorAdd,
        onCustomAnchorRemove
      } = context || {};
    return React.useEffect(() => (onCustomAnchorAdd(), () => onCustomAnchorRemove()), [onCustomAnchorAdd, onCustomAnchorRemove]), /* @__PURE__ */jsx(PopperAnchor, {
      __scopePopper: __scopePopover || POPOVER_SCOPE,
      ...rest,
      ref: forwardedRef
    });
  }),
  PopoverTrigger = React.forwardRef(function (props, forwardedRef) {
    const {
        __scopePopover,
        ...rest
      } = props,
      context = usePopoverContext(__scopePopover),
      anchorTo = context.anchorTo,
      composedTriggerRef = useComposedRefs(forwardedRef, context.triggerRef);
    if (!props.children) return null;
    const trigger = /* @__PURE__ */jsx(View, {
      "aria-expanded": context.open,
      "data-state": getState(context.open),
      ...rest,
      ref: composedTriggerRef,
      onPress: composeEventHandlers(props.onPress, context.onOpenToggle)
    });
    if (anchorTo) {
      const virtualRef = {
        current: {
          getBoundingClientRect: () => isWeb ? DOMRect.fromRect(anchorTo) : anchorTo,
          ...(!isWeb && {
            measure: c => c(anchorTo?.x, anchorTo?.y, anchorTo?.width, anchorTo?.height),
            measureInWindow: c => c(anchorTo?.x, anchorTo?.y, anchorTo?.width, anchorTo?.height)
          })
        }
      };
      return /* @__PURE__ */jsx(PopperAnchor, {
        virtualRef,
        __scopePopper: __scopePopover || POPOVER_SCOPE,
        children: trigger
      });
    }
    return context.hasCustomAnchor ? trigger : /* @__PURE__ */jsx(PopperAnchor, {
      __scopePopper: __scopePopover || POPOVER_SCOPE,
      asChild: !0,
      children: trigger
    });
  }),
  PopoverContent = PopperContentFrame.extractable(React.forwardRef(function (props, forwardedRef) {
    const {
        allowPinchZoom,
        trapFocus,
        disableRemoveScroll = !0,
        zIndex,
        __scopePopover,
        ...contentImplProps
      } = props,
      context = usePopoverContext(__scopePopover),
      contentRef = React.useRef(null),
      composedRefs = useComposedRefs(forwardedRef, contentRef),
      isRightClickOutsideRef = React.useRef(!1),
      [isFullyHidden, setIsFullyHidden] = React.useState(!context.open);
    return context.open && isFullyHidden && setIsFullyHidden(!1), React.useEffect(() => {
      if (!context.open) return;
      const content = contentRef.current;
      if (content) return hideOthers(content);
    }, [context.open]), !context.keepChildrenMounted && isFullyHidden ? null : /* @__PURE__ */jsx(PopoverContentPortal, {
      __scopePopover,
      zIndex: props.zIndex,
      children: /* @__PURE__ */jsx(Stack, {
        pointerEvents: context.open ? "auto" : "none",
        children: /* @__PURE__ */jsx(PopoverContentImpl, {
          ...contentImplProps,
          disableRemoveScroll,
          ref: composedRefs,
          setIsFullyHidden,
          __scopePopover,
          trapFocus: trapFocus ?? context.open,
          disableOutsidePointerEvents: !0,
          onCloseAutoFocus: composeEventHandlers(props.onCloseAutoFocus, event => {
            event.preventDefault(), isRightClickOutsideRef.current || context.triggerRef.current?.focus();
          }),
          onPointerDownOutside: composeEventHandlers(props.onPointerDownOutside, event => {
            const originalEvent = event.detail.originalEvent,
              ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === !0,
              isRightClick = originalEvent.button === 2 || ctrlLeftClick;
            isRightClickOutsideRef.current = isRightClick;
          }, {
            checkDefaultPrevented: !1
          }),
          onFocusOutside: composeEventHandlers(props.onFocusOutside, event => event.preventDefault(), {
            checkDefaultPrevented: !1
          })
        })
      })
    });
  }));
function PopoverRepropagateContext(props) {
  return /* @__PURE__ */jsx(PopperContext.Provider, {
    scope: props.scope,
    ...props.popperContext,
    children: /* @__PURE__ */jsx(PopoverContext.Provider, {
      ...props.context,
      children: props.children
    })
  });
}
function PopoverContentPortal(props) {
  const {
      __scopePopover
    } = props,
    zIndex = props.zIndex ?? 15e4,
    context = usePopoverContext(__scopePopover),
    popperContext = usePopperContext(__scopePopover || POPOVER_SCOPE),
    themeName = useThemeName();
  let contents = props.children;
  return (Platform.OS === "android" || Platform.OS === "ios") && (contents = /* @__PURE__ */jsx(PopoverRepropagateContext, {
    scope: __scopePopover || POPOVER_SCOPE,
    popperContext,
    context,
    children: props.children
  })), /* @__PURE__ */jsx(Portal, {
    zIndex,
    children: /* @__PURE__ */jsxs(Theme, {
      forceClassName: !0,
      name: themeName,
      children: [!!context.open && !context.breakpointActive && /* @__PURE__ */jsx(YStack, {
        fullscreen: !0,
        onPress: composeEventHandlers(props.onPress, context.onOpenToggle)
      }), contents]
    })
  });
}
const PopoverContentImpl = React.forwardRef(function (props, forwardedRef) {
    const {
        trapFocus,
        __scopePopover,
        onOpenAutoFocus,
        onCloseAutoFocus,
        disableOutsidePointerEvents,
        disableFocusScope,
        onEscapeKeyDown,
        onPointerDownOutside,
        onFocusOutside,
        onInteractOutside,
        children,
        disableRemoveScroll,
        freezeContentsWhenHidden,
        setIsFullyHidden,
        ...contentProps
      } = props,
      context = usePopoverContext(__scopePopover),
      {
        open,
        keepChildrenMounted
      } = context,
      popperContext = usePopperContext(__scopePopover || POPOVER_SCOPE),
      handleExitComplete = React.useCallback(() => {
        setIsFullyHidden?.(!0);
      }, [setIsFullyHidden]);
    if (context.breakpointActive) {
      const childrenWithoutScrollView = React.Children.toArray(children).map(child => React.isValidElement(child) && child.type === ScrollView ? child.props.children : child);
      let content = /* @__PURE__ */jsx(ResetPresence, {
        children: childrenWithoutScrollView
      });
      return (Platform.OS === "android" || Platform.OS === "ios") && (content = /* @__PURE__ */jsx(PopperContext.Provider, {
        scope: __scopePopover || POPOVER_SCOPE,
        ...popperContext,
        children: childrenWithoutScrollView
      })), /* @__PURE__ */jsx(AdaptPortalContents, {
        children: content
      });
    }
    return /* @__PURE__ */jsx(Animate, {
      type: "presence",
      present: !!open,
      keepChildrenMounted,
      onExitComplete: handleExitComplete,
      children: /* @__PURE__ */jsx(PopperContent, {
        __scopePopper: __scopePopover || POPOVER_SCOPE,
        "data-state": getState(open),
        id: context.contentId,
        ref: forwardedRef,
        ...contentProps,
        children: /* @__PURE__ */jsx(RemoveScroll, {
          enabled: disableRemoveScroll ? !1 : open,
          allowPinchZoom: !0,
          removeScrollBar: !1,
          style: dspContentsStyle,
          children: /* @__PURE__ */jsx(ResetPresence, {
            children: /* @__PURE__ */jsx(FocusScope, {
              loop: !0,
              enabled: disableFocusScope ? !1 : open,
              trapped: trapFocus,
              onMountAutoFocus: onOpenAutoFocus,
              onUnmountAutoFocus: onCloseAutoFocus,
              children: isWeb ? /* @__PURE__ */jsx("div", {
                style: dspContentsStyle,
                children
              }) : children
            })
          })
        })
      }, context.contentId)
    });
  }),
  dspContentsStyle = {
    display: "contents"
  },
  PopoverClose = React.forwardRef(function (props, forwardedRef) {
    const {
        __scopePopover,
        ...rest
      } = props,
      context = usePopoverContext(__scopePopover);
    return /* @__PURE__ */jsx(YStack, {
      ...rest,
      ref: forwardedRef,
      componentName: "PopoverClose",
      onPress: composeEventHandlers(props.onPress, () => context.onOpenChange(!1, "press"))
    });
  }),
  PopoverArrow = PopperArrow.styleable(function (props, forwardedRef) {
    const {
      __scopePopover,
      ...rest
    } = props;
    return useAdaptIsActive() ? null : /* @__PURE__ */jsx(PopperArrow, {
      __scopePopper: __scopePopover || POPOVER_SCOPE,
      componentName: "PopoverArrow",
      ...rest,
      ref: forwardedRef
    });
  }),
  Popover = withStaticProperties(React.forwardRef(function (props, ref) {
    const id = React.useId();
    return /* @__PURE__ */jsx(AdaptParent, {
      scope: `${id}PopoverContents`,
      portal: !0,
      children: /* @__PURE__ */jsx(PopoverInner, {
        ref,
        id,
        ...props
      })
    });
  }), {
    Anchor: PopoverAnchor,
    Arrow: PopoverArrow,
    Trigger: PopoverTrigger,
    Content: PopoverContent,
    Close: PopoverClose,
    Adapt,
    ScrollView,
    Sheet: Sheet.Controlled
  }),
  PopoverInner = React.forwardRef(function (props, forwardedRef) {
    const {
        children,
        open: openProp,
        defaultOpen,
        onOpenChange,
        __scopePopover,
        keepChildrenMounted,
        hoverable,
        disableFocus,
        id,
        ...restProps
      } = props,
      triggerRef = React.useRef(null),
      [hasCustomAnchor, setHasCustomAnchor] = React.useState(!1),
      viaRef = React.useRef(),
      [open, setOpen] = useControllableState({
        prop: openProp,
        defaultProp: defaultOpen || !1,
        onChange: val => {
          onOpenChange?.(val, viaRef.current);
        }
      }),
      handleOpenChange = useEvent((val, via) => {
        viaRef.current = via, setOpen(val);
      }),
      isAdapted = useAdaptIsActive(),
      floatingContext = useFloatingContext({
        open,
        setOpen: handleOpenChange,
        disable: isAdapted,
        hoverable,
        disableFocus
      }),
      [anchorTo, setAnchorToRaw] = React.useState(),
      setAnchorTo = createShallowSetState(setAnchorToRaw);
    React.useImperativeHandle(forwardedRef, () => ({
      anchorTo: setAnchorTo,
      toggle: () => setOpen(prev => !prev),
      open: () => setOpen(!0),
      close: () => setOpen(!1),
      setOpen
    }));
    const popoverContext = {
        id,
        contentId: React.useId(),
        triggerRef,
        open,
        breakpointActive: isAdapted,
        onOpenChange: handleOpenChange,
        onOpenToggle: useEvent(() => {
          open && isAdapted || setOpen(!open);
        }),
        hasCustomAnchor,
        anchorTo,
        onCustomAnchorAdd: React.useCallback(() => setHasCustomAnchor(!0), []),
        onCustomAnchorRemove: React.useCallback(() => setHasCustomAnchor(!1), []),
        keepChildrenMounted
      },
      contents = /* @__PURE__ */jsx(Popper, {
        __scopePopper: __scopePopover || POPOVER_SCOPE,
        stayInFrame: !0,
        ...restProps,
        children: /* @__PURE__ */jsx(PopoverContext.Provider, {
          scope: __scopePopover,
          ...popoverContext,
          children: /* @__PURE__ */jsx(PopoverSheetController, {
            onOpenChange: setOpen,
            children
          })
        })
      });
    return /* @__PURE__ */jsx(Fragment, {
      children: isWeb ? /* @__PURE__ */jsx(FloatingOverrideContext.Provider, {
        value: floatingContext,
        children: contents
      }) : contents
    });
  });
function getState(open) {
  return open ? "open" : "closed";
}
const PopoverSheetController = ({
    __scopePopover,
    ...props
  }) => {
    const context = usePopoverContext(__scopePopover),
      showSheet = useShowPopoverSheet(context),
      breakpointActive = context.breakpointActive,
      getShowSheet = useGet(showSheet);
    return /* @__PURE__ */jsx(SheetController, {
      onOpenChange: val => {
        getShowSheet() && props.onOpenChange?.(val);
      },
      open: context.open,
      hidden: breakpointActive === !1,
      children: props.children
    });
  },
  useShowPopoverSheet = context => {
    const isAdapted = useAdaptIsActive();
    return context.open === !1 ? !1 : isAdapted;
  };
export { Popover, PopoverAnchor, PopoverArrow, PopoverClose, PopoverContent, PopoverContext, PopoverTrigger, usePopoverContext };
//# sourceMappingURL=Popover.mjs.map
