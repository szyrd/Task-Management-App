var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf, __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: !0 });
}, __copyProps = (to, from, except, desc) => {
  if (from && typeof from == "object" || typeof from == "function")
    for (let key of __getOwnPropNames(from))
      !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: !0 }) : target,
  mod
)), __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: !0 }), mod);
var Popover_exports = {};
__export(Popover_exports, {
  Popover: () => Popover,
  PopoverAnchor: () => PopoverAnchor,
  PopoverArrow: () => PopoverArrow,
  PopoverClose: () => PopoverClose,
  PopoverContent: () => PopoverContent,
  PopoverContext: () => PopoverContext,
  PopoverTrigger: () => PopoverTrigger,
  usePopoverContext: () => usePopoverContext
});
module.exports = __toCommonJS(Popover_exports);
var import_polyfill_dev = require("@tamagui/polyfill-dev"), import_adapt = require("@tamagui/adapt"), import_animate = require("@tamagui/animate"), import_animate_presence = require("@tamagui/animate-presence"), import_aria_hidden = require("@tamagui/aria-hidden"), import_compose_refs = require("@tamagui/compose-refs"), import_constants = require("@tamagui/constants"), import_core = require("@tamagui/core"), import_floating = require("@tamagui/floating"), import_focus_scope = require("@tamagui/focus-scope"), import_helpers = require("@tamagui/helpers"), import_popper = require("@tamagui/popper"), import_portal = require("@tamagui/portal"), import_remove_scroll = require("@tamagui/remove-scroll"), import_sheet = require("@tamagui/sheet"), import_stacks = require("@tamagui/stacks"), import_use_controllable_state = require("@tamagui/use-controllable-state"), React = __toESM(require("react")), import_react_native = require("react-native-web"), import_useFloatingContext = require("./useFloatingContext"), import_jsx_runtime = require("react/jsx-runtime");
const POPOVER_SCOPE = "PopoverScope", PopoverContext = (0, import_core.createStyledContext)({}), usePopoverContext = PopoverContext.useStyledContext, PopoverAnchor = React.forwardRef(function(props, forwardedRef) {
  const { __scopePopover, ...rest } = props, context = usePopoverContext(__scopePopover), { onCustomAnchorAdd, onCustomAnchorRemove } = context || {};
  return React.useEffect(() => (onCustomAnchorAdd(), () => onCustomAnchorRemove()), [onCustomAnchorAdd, onCustomAnchorRemove]), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
    import_popper.PopperAnchor,
    {
      __scopePopper: __scopePopover || POPOVER_SCOPE,
      ...rest,
      ref: forwardedRef
    }
  );
}), PopoverTrigger = React.forwardRef(function(props, forwardedRef) {
  const { __scopePopover, ...rest } = props, context = usePopoverContext(__scopePopover), anchorTo = context.anchorTo, composedTriggerRef = (0, import_compose_refs.useComposedRefs)(forwardedRef, context.triggerRef);
  if (!props.children) return null;
  const trigger = /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
    import_core.View,
    {
      "aria-expanded": context.open,
      "data-state": getState(context.open),
      ...rest,
      ref: composedTriggerRef,
      onPress: (0, import_helpers.composeEventHandlers)(props.onPress, context.onOpenToggle)
    }
  );
  if (anchorTo) {
    const virtualRef = {
      current: {
        getBoundingClientRect: () => import_constants.isWeb ? DOMRect.fromRect(anchorTo) : anchorTo,
        ...!import_constants.isWeb && {
          measure: (c) => c(anchorTo?.x, anchorTo?.y, anchorTo?.width, anchorTo?.height),
          measureInWindow: (c) => c(anchorTo?.x, anchorTo?.y, anchorTo?.width, anchorTo?.height)
        }
      }
    };
    return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
      import_popper.PopperAnchor,
      {
        virtualRef,
        __scopePopper: __scopePopover || POPOVER_SCOPE,
        children: trigger
      }
    );
  }
  return context.hasCustomAnchor ? trigger : /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_popper.PopperAnchor, { __scopePopper: __scopePopover || POPOVER_SCOPE, asChild: !0, children: trigger });
}), PopoverContent = import_popper.PopperContentFrame.extractable(
  React.forwardRef(function(props, forwardedRef) {
    const {
      allowPinchZoom,
      trapFocus,
      disableRemoveScroll = !0,
      zIndex,
      __scopePopover,
      ...contentImplProps
    } = props, context = usePopoverContext(__scopePopover), contentRef = React.useRef(null), composedRefs = (0, import_compose_refs.useComposedRefs)(forwardedRef, contentRef), isRightClickOutsideRef = React.useRef(!1), [isFullyHidden, setIsFullyHidden] = React.useState(!context.open);
    return context.open && isFullyHidden && setIsFullyHidden(!1), React.useEffect(() => {
      if (!context.open) return;
      const content = contentRef.current;
      if (content) return (0, import_aria_hidden.hideOthers)(content);
    }, [context.open]), !context.keepChildrenMounted && isFullyHidden ? null : /* @__PURE__ */ (0, import_jsx_runtime.jsx)(PopoverContentPortal, { __scopePopover, zIndex: props.zIndex, children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_core.Stack, { pointerEvents: context.open ? "auto" : "none", children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
      PopoverContentImpl,
      {
        ...contentImplProps,
        disableRemoveScroll,
        ref: composedRefs,
        setIsFullyHidden,
        __scopePopover,
        trapFocus: trapFocus ?? context.open,
        disableOutsidePointerEvents: !0,
        onCloseAutoFocus: (0, import_helpers.composeEventHandlers)(props.onCloseAutoFocus, (event) => {
          event.preventDefault(), isRightClickOutsideRef.current || context.triggerRef.current?.focus();
        }),
        onPointerDownOutside: (0, import_helpers.composeEventHandlers)(
          props.onPointerDownOutside,
          (event) => {
            const originalEvent = event.detail.originalEvent, ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === !0, isRightClick = originalEvent.button === 2 || ctrlLeftClick;
            isRightClickOutsideRef.current = isRightClick;
          },
          { checkDefaultPrevented: !1 }
        ),
        onFocusOutside: (0, import_helpers.composeEventHandlers)(
          props.onFocusOutside,
          (event) => event.preventDefault(),
          { checkDefaultPrevented: !1 }
        )
      }
    ) }) });
  })
);
function PopoverRepropagateContext(props) {
  return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_popper.PopperContext.Provider, { scope: props.scope, ...props.popperContext, children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(PopoverContext.Provider, { ...props.context, children: props.children }) });
}
function PopoverContentPortal(props) {
  const { __scopePopover } = props, zIndex = props.zIndex ?? 15e4, context = usePopoverContext(__scopePopover), popperContext = (0, import_popper.usePopperContext)(__scopePopover || POPOVER_SCOPE), themeName = (0, import_core.useThemeName)();
  let contents = props.children;
  return (import_react_native.Platform.OS === "android" || import_react_native.Platform.OS === "ios") && (contents = /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
    PopoverRepropagateContext,
    {
      scope: __scopePopover || POPOVER_SCOPE,
      popperContext,
      context,
      children: props.children
    }
  )), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_portal.Portal, { zIndex, children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_core.Theme, { forceClassName: !0, name: themeName, children: [
    !!context.open && !context.breakpointActive && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
      import_stacks.YStack,
      {
        fullscreen: !0,
        onPress: (0, import_helpers.composeEventHandlers)(props.onPress, context.onOpenToggle)
      }
    ),
    contents
  ] }) });
}
const PopoverContentImpl = React.forwardRef(function(props, forwardedRef) {
  const {
    trapFocus,
    __scopePopover,
    onOpenAutoFocus,
    onCloseAutoFocus,
    disableOutsidePointerEvents,
    disableFocusScope,
    onEscapeKeyDown,
    onPointerDownOutside,
    onFocusOutside,
    onInteractOutside,
    children,
    disableRemoveScroll,
    freezeContentsWhenHidden,
    setIsFullyHidden,
    ...contentProps
  } = props, context = usePopoverContext(__scopePopover), { open, keepChildrenMounted } = context, popperContext = (0, import_popper.usePopperContext)(__scopePopover || POPOVER_SCOPE), handleExitComplete = React.useCallback(() => {
    setIsFullyHidden?.(!0);
  }, [setIsFullyHidden]);
  if (context.breakpointActive) {
    const childrenWithoutScrollView = React.Children.toArray(children).map((child) => React.isValidElement(child) && child.type === import_react_native.ScrollView ? child.props.children : child);
    let content = /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_animate_presence.ResetPresence, { children: childrenWithoutScrollView });
    return (import_react_native.Platform.OS === "android" || import_react_native.Platform.OS === "ios") && (content = /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
      import_popper.PopperContext.Provider,
      {
        scope: __scopePopover || POPOVER_SCOPE,
        ...popperContext,
        children: childrenWithoutScrollView
      }
    )), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_adapt.AdaptPortalContents, { children: content });
  }
  return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
    import_animate.Animate,
    {
      type: "presence",
      present: !!open,
      keepChildrenMounted,
      onExitComplete: handleExitComplete,
      children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
        import_popper.PopperContent,
        {
          __scopePopper: __scopePopover || POPOVER_SCOPE,
          "data-state": getState(open),
          id: context.contentId,
          ref: forwardedRef,
          ...contentProps,
          children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
            import_remove_scroll.RemoveScroll,
            {
              enabled: disableRemoveScroll ? !1 : open,
              allowPinchZoom: !0,
              removeScrollBar: !1,
              style: dspContentsStyle,
              children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_animate_presence.ResetPresence, { children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
                import_focus_scope.FocusScope,
                {
                  loop: !0,
                  enabled: disableFocusScope ? !1 : open,
                  trapped: trapFocus,
                  onMountAutoFocus: onOpenAutoFocus,
                  onUnmountAutoFocus: onCloseAutoFocus,
                  children: import_constants.isWeb ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", { style: dspContentsStyle, children }) : children
                }
              ) })
            }
          )
        },
        context.contentId
      )
    }
  );
}), dspContentsStyle = {
  display: "contents"
}, PopoverClose = React.forwardRef(function(props, forwardedRef) {
  const { __scopePopover, ...rest } = props, context = usePopoverContext(__scopePopover);
  return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
    import_stacks.YStack,
    {
      ...rest,
      ref: forwardedRef,
      componentName: "PopoverClose",
      onPress: (0, import_helpers.composeEventHandlers)(
        props.onPress,
        () => context.onOpenChange(!1, "press")
      )
    }
  );
}), PopoverArrow = import_popper.PopperArrow.styleable(
  function(props, forwardedRef) {
    const { __scopePopover, ...rest } = props;
    return (0, import_adapt.useAdaptIsActive)() ? null : /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
      import_popper.PopperArrow,
      {
        __scopePopper: __scopePopover || POPOVER_SCOPE,
        componentName: "PopoverArrow",
        ...rest,
        ref: forwardedRef
      }
    );
  }
), Popover = (0, import_helpers.withStaticProperties)(
  React.forwardRef(
    function(props, ref) {
      const id = React.useId();
      return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_adapt.AdaptParent, { scope: `${id}PopoverContents`, portal: !0, children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(PopoverInner, { ref, id, ...props }) });
    }
  ),
  {
    Anchor: PopoverAnchor,
    Arrow: PopoverArrow,
    Trigger: PopoverTrigger,
    Content: PopoverContent,
    Close: PopoverClose,
    Adapt: import_adapt.Adapt,
    ScrollView: import_react_native.ScrollView,
    Sheet: import_sheet.Sheet.Controlled
  }
), PopoverInner = React.forwardRef(function(props, forwardedRef) {
  const {
    children,
    open: openProp,
    defaultOpen,
    onOpenChange,
    __scopePopover,
    keepChildrenMounted,
    hoverable,
    disableFocus,
    id,
    ...restProps
  } = props, triggerRef = React.useRef(null), [hasCustomAnchor, setHasCustomAnchor] = React.useState(!1), viaRef = React.useRef(), [open, setOpen] = (0, import_use_controllable_state.useControllableState)({
    prop: openProp,
    defaultProp: defaultOpen || !1,
    onChange: (val) => {
      onOpenChange?.(val, viaRef.current);
    }
  }), handleOpenChange = (0, import_core.useEvent)((val, via) => {
    viaRef.current = via, setOpen(val);
  }), isAdapted = (0, import_adapt.useAdaptIsActive)(), floatingContext = (0, import_useFloatingContext.useFloatingContext)({
    open,
    setOpen: handleOpenChange,
    disable: isAdapted,
    hoverable,
    disableFocus
  }), [anchorTo, setAnchorToRaw] = React.useState(), setAnchorTo = (0, import_core.createShallowSetState)(
    setAnchorToRaw
  );
  React.useImperativeHandle(forwardedRef, () => ({
    anchorTo: setAnchorTo,
    toggle: () => setOpen((prev) => !prev),
    open: () => setOpen(!0),
    close: () => setOpen(!1),
    setOpen
  }));
  const popoverContext = {
    id,
    contentId: React.useId(),
    triggerRef,
    open,
    breakpointActive: isAdapted,
    onOpenChange: handleOpenChange,
    onOpenToggle: (0, import_core.useEvent)(() => {
      open && isAdapted || setOpen(!open);
    }),
    hasCustomAnchor,
    anchorTo,
    onCustomAnchorAdd: React.useCallback(() => setHasCustomAnchor(!0), []),
    onCustomAnchorRemove: React.useCallback(() => setHasCustomAnchor(!1), []),
    keepChildrenMounted
  }, contents = /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_popper.Popper, { __scopePopper: __scopePopover || POPOVER_SCOPE, stayInFrame: !0, ...restProps, children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(PopoverContext.Provider, { scope: __scopePopover, ...popoverContext, children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(PopoverSheetController, { onOpenChange: setOpen, children }) }) });
  return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: import_constants.isWeb ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_floating.FloatingOverrideContext.Provider, { value: floatingContext, children: contents }) : contents });
});
function getState(open) {
  return open ? "open" : "closed";
}
const PopoverSheetController = ({
  __scopePopover,
  ...props
}) => {
  const context = usePopoverContext(__scopePopover), showSheet = useShowPopoverSheet(context), breakpointActive = context.breakpointActive, getShowSheet = (0, import_core.useGet)(showSheet);
  return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
    import_sheet.SheetController,
    {
      onOpenChange: (val) => {
        getShowSheet() && props.onOpenChange?.(val);
      },
      open: context.open,
      hidden: breakpointActive === !1,
      children: props.children
    }
  );
}, useShowPopoverSheet = (context) => {
  const isAdapted = (0, import_adapt.useAdaptIsActive)();
  return context.open === !1 ? !1 : isAdapted;
};
//# sourceMappingURL=Popover.js.map
