"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf, __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: !0 });
}, __copyProps = (to, from, except, desc) => {
  if (from && typeof from == "object" || typeof from == "function")
    for (let key of __getOwnPropNames(from))
      !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: !0 }) : target,
  mod
)), __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: !0 }), mod);
var useTheme_exports = {};
__export(useTheme_exports, {
  activeThemeManagers: () => activeThemeManagers,
  getThemeManager: () => getThemeManager,
  getThemeProxied: () => getThemeProxied,
  useChangeThemeEffect: () => useChangeThemeEffect,
  useTheme: () => useTheme,
  useThemeWithState: () => useThemeWithState
});
module.exports = __toCommonJS(useTheme_exports);
var import_react = __toESM(require("react")), import_constants = require("@tamagui/constants"), import_config = require("../config"), import_createVariable = require("../createVariable"), import_ThemeManager = require("../helpers/ThemeManager"), import_ThemeManagerContext = require("../helpers/ThemeManagerContext"), import_createShallowSetState = require("../helpers/createShallowSetState"), import_shouldDeoptDueToParentScheme = require("./shouldDeoptDueToParentScheme"), emptyProps = {
  name: null
}, cached;
function getDefaultThemeProxied() {
  if (cached) return cached;
  var config = (0, import_config.getConfig)(), name = config.themes.light ? "light" : Object.keys(config.themes)[0], defaultTheme = config.themes[name];
  return cached = getThemeProxied({
    theme: defaultTheme,
    name
  }), cached;
}
var useTheme = function() {
  var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : emptyProps, [_, theme] = useThemeWithState(props), res = theme || getDefaultThemeProxied();
  return res;
}, useThemeWithState = function(props) {
  var keys = import_react.default.useRef([]), changedThemeState = useChangeThemeEffect(props, !1, keys.current, import_constants.isServer ? void 0 : function() {
    var _props_shouldUpdate, _props_shouldUpdate1, next = (_props_shouldUpdate1 = (_props_shouldUpdate = props.shouldUpdate) === null || _props_shouldUpdate === void 0 ? void 0 : _props_shouldUpdate.call(props)) !== null && _props_shouldUpdate1 !== void 0 ? _props_shouldUpdate1 : keys.current.length > 0 ? !0 : void 0;
    if (process.env.NODE_ENV === "development" && typeof props.debug == "string" && props.debug !== "profile") {
      var _props_shouldUpdate2;
      console.info(`  \u{1F3A8} useTheme() shouldUpdate? tracking keys ${keys.current.length} ${(_props_shouldUpdate2 = props.shouldUpdate) === null || _props_shouldUpdate2 === void 0 ? void 0 : _props_shouldUpdate2.call(props)}`, next);
    }
    return next;
  }), { themeManager, state } = changedThemeState;
  process.env.NODE_ENV === "development" && (state != null && state.theme || process.env.TAMAGUI_DISABLE_NO_THEME_WARNING !== "1" && console.error(`[tamagui] No theme found, this could be due to an invalid theme name (given theme props ${JSON.stringify(props)}).

If this is intended and you are using Tamagui without any themes, you can disable this warning by setting the environment variable TAMAGUI_DISABLE_NO_THEME_WARNING=1`));
  var themeProxied = import_react.default.useMemo(function() {
    return keys.current = [], !themeManager || !(state != null && state.theme) ? {} : getThemeProxied(state, props.deopt, themeManager, keys.current, props.debug);
  }, [
    state == null ? void 0 : state.theme,
    themeManager,
    props.deopt,
    props.debug
  ]);
  return process.env.NODE_ENV === "development" && props.debug === "verbose" && (console.groupCollapsed(`  \u{1F539} [${themeManager == null ? void 0 : themeManager.id}] useTheme =>`, state == null ? void 0 : state.name), console.info("returning state", changedThemeState.state, changedThemeState.isNewTheme, "from props", props), console.groupEnd()), [
    changedThemeState,
    themeProxied
  ];
};
function getThemeProxied(param) {
  var { theme, name, scheme } = param, deopt = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, themeManager = arguments.length > 2 ? arguments[2] : void 0, keys = arguments.length > 3 ? arguments[3] : void 0, debug = arguments.length > 4 ? arguments[4] : void 0;
  if (!theme) return {};
  var config = (0, import_config.getConfig)();
  function track(key) {
    keys && !keys.includes(key) && (keys.length || setTimeout(function() {
      themeManager == null || themeManager.selfUpdate();
    }), keys.push(key), process.env.NODE_ENV === "development" && debug && console.info(` \u{1F3A8} useTheme() tracking new key: ${key}`));
  }
  return new Proxy(theme, {
    has(_, key) {
      if (Reflect.has(theme, key))
        return !0;
      if (typeof key == "string")
        return key[0] === "$" && (key = key.slice(1)), themeManager == null ? void 0 : themeManager.allKeys.has(key);
    },
    get(_, key) {
      if (
        // dont ask me, idk why but on hermes you can see that useTheme()[undefined] passes in STRING undefined to proxy
        // if someone is crazy enough to use "undefined" as a theme key then this not working is on them
        key !== "undefined" && typeof key == "string"
      ) {
        var keyString = key[0] === "$" ? key.slice(1) : key, val = theme[keyString];
        if (val && typeof val == "object")
          return new Proxy(val, {
            // when they touch the actual value we only track it
            // if its a variable (web), its ignored!
            get(_2, subkey) {
              if (subkey === "val")
                globalThis.tamaguiAvoidTracking || (process.env.NODE_ENV === "development" && debug === "verbose" && console.info(" \u{1F3A8} useTheme() tracking new key because of .val access", new Error().stack), track(keyString));
              else if (subkey === "get")
                return function(platform) {
                  var outVal = (0, import_createVariable.getVariable)(val);
                  if (platform !== "web" && import_constants.isIos && !deopt && (0, import_config.getSetting)("fastSchemeChange") && !(0, import_shouldDeoptDueToParentScheme.shouldDeoptDueToParentScheme)(themeManager) && scheme) {
                    var _config_themes_name, _config_themes_oppositeName, oppositeScheme = scheme === "dark" ? "light" : "dark", oppositeName = name.replace(scheme, oppositeScheme), color = (0, import_createVariable.getVariable)((_config_themes_name = config.themes[name]) === null || _config_themes_name === void 0 ? void 0 : _config_themes_name[keyString]), oppositeColor = (0, import_createVariable.getVariable)((_config_themes_oppositeName = config.themes[oppositeName]) === null || _config_themes_oppositeName === void 0 ? void 0 : _config_themes_oppositeName[keyString]), dynamicVal = {
                      dynamic: {
                        [scheme]: color,
                        [oppositeScheme]: oppositeColor
                      }
                    };
                    return dynamicVal;
                  }
                  return process.env.NODE_ENV === "development" && debug && console.info(` \u{1F3A8} useTheme() tracking new key because of: 
                        not web: ${platform !== "web"}
                        isIOS: ${import_constants.isIos}
                        deopt: ${deopt}
                        fastScheme: ${(0, import_config.getSetting)("fastSchemeChange")}
                        inversed: ${getIsInversed(themeManager)}
                      `), track(keyString), outVal;
                };
              return Reflect.get(val, subkey);
            }
          });
        if (process.env.NODE_ENV === "development" && process.env.TAMAGUI_FEAT_THROW_ON_MISSING_THEME_VALUE === "1")
          throw new Error(`[tamagui] No theme key "${key}" found in theme ${name}. 
  Keys in theme: ${Object.keys(theme).join(", ")}`);
      }
      return Reflect.get(_, key);
    }
  });
}
function getIsInversed(manager) {
  for (var isInversed = !1, cur = manager; cur; ) {
    if (!cur.parentManager) return isInversed;
    cur.parentManager.state.scheme !== cur.state.scheme && (isInversed = !isInversed), cur = cur.parentManager;
  }
  return !1;
}
var activeThemeManagers = /* @__PURE__ */ new Set(), _uidToManager = /* @__PURE__ */ new WeakMap(), _idToUID = {}, getId = function(id) {
  return _idToUID[id];
}, getThemeManager = function(id) {
  return _uidToManager.get(getId(id));
}, registerThemeManager = function(t) {
  if (!_idToUID[t.id]) {
    var id = _idToUID[t.id] = {};
    _uidToManager.set(id, t);
  }
}, ogLog = console.error, preventWarnSetState = process.env.NODE_ENV === "production" ? ogLog : (
  // temporary fix for logs, they are harmless in that i've tried to rewrite this
  // a few times using the "right" ways, but they are always slower. maybe skill issue
  function(a) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++)
      args[_key - 1] = arguments[_key];
    if (!(typeof a == "string" && a.includes("Cannot update a component")))
      return ogLog(a, ...args);
  }
), useChangeThemeEffect = function(props) {
  var isRoot = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, keys = arguments.length > 2 ? arguments[2] : void 0, shouldUpdate = arguments.length > 3 ? arguments[3] : void 0, { disable } = props, parentManagerId = import_react.default.useContext(import_ThemeManagerContext.ThemeManagerIDContext), parentManager = getThemeManager(parentManagerId);
  if (!isRoot && !parentManager || disable)
    return {
      isNewTheme: !1,
      state: parentManager == null ? void 0 : parentManager.state,
      themeManager: parentManager
    };
  var [themeState, setThemeState] = import_react.default.useState(createState), { state, mounted, isNewTheme, themeManager, prevState } = themeState, isInversingOnMount = !!(!themeState.mounted && props.inverse);
  function getShouldUpdateTheme() {
    var manager = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : themeManager, nextState = arguments.length > 1 ? arguments[1] : void 0, prevState2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : state, forceShouldChange = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1, forceUpdate = shouldUpdate == null ? void 0 : shouldUpdate();
    if (!(!manager || !forceShouldChange && forceUpdate === !1)) {
      var next2 = nextState || manager.getState(props, parentManager);
      if (forceShouldChange)
        return next2;
      if (next2 && !(forceUpdate !== !0 && !manager.getStateShouldChange(next2, prevState2)))
        return next2;
    }
  }
  if (themeManager && getShouldUpdateTheme(themeManager)) {
    var _next_state, _themeState_state, next = createState(themeState);
    ((_next_state = next.state) === null || _next_state === void 0 ? void 0 : _next_state.name) !== ((_themeState_state = themeState.state) === null || _themeState_state === void 0 ? void 0 : _themeState_state.name) && (setThemeState(next), console.error = preventWarnSetState, themeManager.notify(), console.error = ogLog);
  }
  if (import_constants.isServer || (import_react.default.useLayoutEffect(function() {
    themeManager && state && prevState && state !== prevState && themeManager.notify();
  }, [
    state
  ]), import_react.default.useEffect(function() {
    if (themeManager) {
      if (props.inverse && !mounted) {
        setThemeState(function(prev) {
          return createState({
            ...prev,
            mounted: !0
          });
        });
        return;
      }
      (isNewTheme || getShouldUpdateTheme(themeManager)) && (activeThemeManagers.add(themeManager), setThemeState(createState));
      var selfListenerDispose = themeManager.onChangeTheme(function(_a, _b, forced) {
        forced && setThemeState(function(prev) {
          var next2 = createState(prev, forced !== "self");
          return next2;
        });
      }, !0), disposeChangeListener = parentManager == null ? void 0 : parentManager.onChangeTheme(function(name, manager, forced) {
        var force = forced || (shouldUpdate == null ? void 0 : shouldUpdate()) || props.deopt || props["disable-child-theme"], shouldTryUpdate = force ?? !!(keys != null && keys.length || isNewTheme);
        process.env.NODE_ENV === "development" && props.debug === "verbose" && console.info(" \u{1F538} onChange", {
          id: themeManager.id,
          force,
          shouldTryUpdate,
          props,
          name,
          keys
        }), shouldTryUpdate && setThemeState(function(prev) {
          return createState(prev, force);
        });
      }, themeManager.id);
      return function() {
        selfListenerDispose(), disposeChangeListener == null || disposeChangeListener(), isNewTheme && activeThemeManagers.delete(themeManager);
      };
    }
  }, [
    themeManager,
    parentManager,
    isNewTheme,
    props.componentName,
    props.inverse,
    props.name,
    props.reset,
    mounted
  ]), process.env.NODE_ENV === "development" && props.debug !== "profile" && import_react.default.useEffect(function() {
    var _globalThis, _TamaguiThemeManagers, _;
    return (_ = (_globalThis = globalThis)[_TamaguiThemeManagers = "TamaguiThemeManagers"]) !== null && _ !== void 0 || (_globalThis[_TamaguiThemeManagers] = /* @__PURE__ */ new Set()), globalThis.TamaguiThemeManagers.add(themeManager), function() {
      globalThis.TamaguiThemeManagers.delete(themeManager);
    };
  }, [
    themeManager
  ])), import_constants.isWeb && isInversingOnMount)
    return {
      isNewTheme: !1,
      inversed: !1,
      themeManager: parentManager,
      state: {
        name: "",
        ...parentManager == null ? void 0 : parentManager.state,
        className: ""
      }
    };
  return {
    state,
    isNewTheme,
    inversed: !!props.inverse,
    themeManager
  };
  function createState(prev) {
    var force = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
    if (prev && (shouldUpdate == null ? void 0 : shouldUpdate()) === !1 && !force)
      return prev;
    var themeManager2 = parentManager, state2, hasThemeUpdatingProps = (0, import_ThemeManager.getHasThemeUpdatingProps)(props);
    if (hasThemeUpdatingProps) {
      var getNewThemeManager = function() {
        return new import_ThemeManager.ThemeManager(props, isRoot ? "root" : parentManager);
      };
      if (prev != null && prev.themeManager) {
        themeManager2 = prev.themeManager;
        var forceChange = force || !!(keys != null && keys.length), next2 = themeManager2.getState(props, parentManager), nextState = getShouldUpdateTheme(themeManager2, next2, prev.state, forceChange);
        nextState ? (state2 = nextState, !prev.isNewTheme && !isRoot ? themeManager2 = getNewThemeManager() : themeManager2.updateState(nextState)) : prev.isNewTheme && parentManager && !next2 && (themeManager2 = parentManager);
      } else
        themeManager2 = getNewThemeManager(), state2 = {
          ...themeManager2.state
        };
    }
    var isNewTheme2 = !!(themeManager2 !== parentManager || props.inverse);
    isNewTheme2 && registerThemeManager(themeManager2);
    var isWebSSR = import_constants.isWeb ? !(0, import_config.getSetting)("disableSSR") : !1, mounted2 = isWebSSR ? isRoot || (prev == null ? void 0 : prev.mounted) : !0;
    state2 || (isNewTheme2 ? state2 = themeManager2.state : (state2 = parentManager.state, themeManager2 = parentManager));
    var response = {
      themeManager: themeManager2,
      isNewTheme: isNewTheme2,
      mounted: mounted2,
      inversed: props.inverse
    }, shouldReturnPrev = prev && !force && // isEqualShallow uses the second arg as the keys so this should compare without state first...
    (0, import_createShallowSetState.isEqualShallow)(prev, response) && // ... and then compare just the state, because we make a new state obj but is likely the same
    (0, import_createShallowSetState.isEqualShallow)(prev.state, state2);
    if (prev && shouldReturnPrev)
      return prev;
    if (response.state = state2, response.prevState = prev == null ? void 0 : prev.state, process.env.NODE_ENV === "development" && props.debug && import_constants.isClient) {
      console.groupCollapsed(`\u{1F537} [${themeManager2.id}] useChangeThemeEffect createState`);
      var parentState = {
        ...parentManager == null ? void 0 : parentManager.state
      }, parentId = parentManager == null ? void 0 : parentManager.id, themeManagerState = {
        ...themeManager2.state
      };
      console.info({
        props,
        parentState,
        parentId,
        themeManager: themeManager2,
        prev,
        response,
        themeManagerState
      }), console.groupEnd();
    }
    return response;
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  activeThemeManagers,
  getThemeManager,
  getThemeProxied,
  useChangeThemeEffect,
  useTheme,
  useThemeWithState
});
//# sourceMappingURL=useTheme.js.map
