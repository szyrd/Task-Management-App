"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: !0 });
}, __copyProps = (to, from, except, desc) => {
  if (from && typeof from == "object" || typeof from == "function")
    for (let key of __getOwnPropNames(from))
      !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: !0 }), mod);
var useComponentState_exports = {};
__export(useComponentState_exports, {
  useComponentState: () => useComponentState
});
module.exports = __toCommonJS(useComponentState_exports);
var import_constants = require("@tamagui/constants"), import_use_did_finish_ssr = require("@tamagui/use-did-finish-ssr"), import_react = require("react"), import_defaultComponentState = require("../defaultComponentState"), import_createShallowSetState = require("../helpers/createShallowSetState"), import_isObj = require("../helpers/isObj"), import_log = require("../helpers/log"), useComponentState = function(props, param, staticConfig, config) {
  var { animationDriver, groups } = param, _animationDriver_usePresence, isHydrated = (0, import_use_did_finish_ssr.useDidFinishSSR)(), useAnimations = animationDriver == null ? void 0 : animationDriver.useAnimations, stateRef = (0, import_react.useRef)(void 0);
  stateRef.current || (stateRef.current = {});
  var hasAnimationProp = !!("animation" in props || props.style && hasAnimatedStyleValue(props.style)), supportsCSSVars = animationDriver == null ? void 0 : animationDriver.supportsCSSVars, curStateRef = stateRef.current, willBeAnimatedClient = function() {
    var next = !!(hasAnimationProp && !staticConfig.isHOC && useAnimations);
    return !!(next || curStateRef.hasAnimated);
  }(), willBeAnimated = !import_constants.isServer && willBeAnimatedClient;
  willBeAnimated && !curStateRef.hasAnimated && (curStateRef.hasAnimated = !0);
  var { disableClassName } = props, presence = willBeAnimated && props.animatePresence !== !1 && (animationDriver == null || (_animationDriver_usePresence = animationDriver.usePresence) === null || _animationDriver_usePresence === void 0 ? void 0 : _animationDriver_usePresence.call(animationDriver)) || null, presenceState = presence == null ? void 0 : presence[2], isExiting = (presenceState == null ? void 0 : presenceState.isPresent) === !1, isEntering = (presenceState == null ? void 0 : presenceState.isPresent) === !0 && presenceState.initial !== !1, hasEnterStyle = !!props.enterStyle, hasAnimationThatNeedsHydrate = hasAnimationProp && !isHydrated && ((animationDriver == null ? void 0 : animationDriver.isReactNative) || !supportsCSSVars), hasEnterState = hasEnterStyle || isEntering, shouldEnter = hasEnterState || hasAnimationThatNeedsHydrate || // disableClassName doesnt work server side, only client, so needs hydrate
  // this is just for a better ux, supports css variables for light/dark, media queries, etc
  disableClassName, initialState = shouldEnter ? (
    // on the very first render we switch all spring animation drivers to css rendering
    // this is because we need to use css variables, which they don't support to do proper SSR
    // without flickers of the wrong colors.
    // but once we do that initial hydration and we are in client side rendering mode,
    // we can avoid the extra re-render on mount
    hasEnterState ? import_defaultComponentState.defaultComponentStateShouldEnter : import_defaultComponentState.defaultComponentState
  ) : import_defaultComponentState.defaultComponentStateMounted, disabled = isDisabled(props);
  disabled != null && (initialState.disabled = disabled);
  var states = (0, import_react.useState)(initialState), state = props.forceStyle ? {
    ...states[0],
    [props.forceStyle]: !0
  } : states[0], setState = states[1], isAnimated = willBeAnimated;
  import_constants.isWeb && hasAnimationThatNeedsHydrate && !staticConfig.isHOC && !isHydrated && (isAnimated = !1, curStateRef.willHydrate = !0), disabled !== state.disabled && (state.disabled = disabled, disabled && Object.assign(state, import_defaultComponentState.defaultComponentStateMounted), setState({
    ...state
  }));
  var setStateShallow = (0, import_createShallowSetState.createShallowSetState)(setState, disabled, !1, props.debug);
  if (presenceState && isAnimated && isHydrated && staticConfig.variants) {
    process.env.NODE_ENV === "development" && props.debug === "verbose" && console.warn(`has presenceState ${JSON.stringify(presenceState)}`);
    var { enterVariant, exitVariant, enterExitVariant, custom } = presenceState;
    (0, import_isObj.isObj)(custom) && Object.assign(props, custom);
    var exv = exitVariant ?? enterExitVariant, env = enterVariant ?? enterExitVariant;
    state.unmounted && env && staticConfig.variants[env] ? (process.env.NODE_ENV === "development" && props.debug === "verbose" && console.warn(`Animating presence ENTER "${env}"`), props[env] = !0) : isExiting && exv && (process.env.NODE_ENV === "development" && props.debug === "verbose" && console.warn(`Animating presence EXIT "${exv}"`), props[exv] = exitVariant !== enterExitVariant);
  }
  var noClass = !import_constants.isWeb || !!props.forceStyle;
  if (import_constants.isWeb && (!import_constants.isServer || isHydrated)) {
    var isAnimatedAndHydrated = isAnimated && !supportsCSSVars, isClassNameDisabled = !staticConfig.acceptsClassName && (config.disableSSR || !state.unmounted), isDisabledManually = disableClassName && !state.unmounted;
    (isAnimatedAndHydrated || isDisabledManually || isClassNameDisabled) && (noClass = !0, process.env.NODE_ENV === "development" && props.debug && (0, import_log.log)("avoiding className", {
      isAnimatedAndHydrated,
      isDisabledManually,
      isClassNameDisabled
    }));
  }
  var groupName = props.group;
  if (groupName && !curStateRef.group) {
    var listeners = /* @__PURE__ */ new Set();
    curStateRef.group = {
      listeners,
      emit(name, state2) {
        listeners.forEach(function(l) {
          return l(name, state2);
        });
      },
      subscribe(cb) {
        return listeners.add(cb), function() {
          listeners.delete(cb);
        };
      }
    };
  }
  if (groupName) {
    var groupContextState = groups.state, og = setStateShallow;
    setStateShallow = function(state2) {
      og(state2), curStateRef.group.emit(groupName, {
        pseudo: state2
      });
      var next = {
        ...groupContextState[groupName],
        ...state2
      };
      groupContextState[groupName] = next;
    };
  }
  return {
    curStateRef,
    disabled,
    groupName,
    hasAnimationProp,
    hasEnterStyle,
    isAnimated,
    isExiting,
    isHydrated,
    presence,
    presenceState,
    setState,
    setStateShallow,
    noClass,
    state,
    stateRef,
    supportsCSSVars,
    willBeAnimated,
    willBeAnimatedClient
  };
};
function hasAnimatedStyleValue(style) {
  return Object.keys(style).some(function(k) {
    var val = style[k];
    return val && typeof val == "object" && "_animation" in val;
  });
}
var isDisabled = function(props) {
  var _props_accessibilityState;
  return props.disabled || ((_props_accessibilityState = props.accessibilityState) === null || _props_accessibilityState === void 0 ? void 0 : _props_accessibilityState.disabled) || props["aria-disabled"] || props.accessibilityDisabled || !1;
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  useComponentState
});
//# sourceMappingURL=useComponentState.js.map
