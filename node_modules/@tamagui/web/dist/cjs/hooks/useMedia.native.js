"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf, __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: !0 });
}, __copyProps = (to, from, except, desc) => {
  if (from && typeof from == "object" || typeof from == "function")
    for (let key of __getOwnPropNames(from))
      !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: !0 }) : target,
  mod
)), __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: !0 }), mod);
var useMedia_exports = {};
__export(useMedia_exports, {
  _disableMediaTouch: () => _disableMediaTouch,
  configureMedia: () => configureMedia,
  getMedia: () => getMedia,
  getMediaImportanceIfMoreImportant: () => getMediaImportanceIfMoreImportant,
  getMediaKeyImportance: () => getMediaKeyImportance,
  getMediaState: () => getMediaState,
  isMediaKey: () => isMediaKey,
  mediaKeyMatch: () => mediaKeyMatch,
  mediaKeyToQuery: () => mediaKeyToQuery,
  mediaKeys: () => mediaKeys,
  mediaObjectToString: () => mediaObjectToString,
  mediaQueryConfig: () => mediaQueryConfig,
  mediaState: () => mediaState,
  setMediaShouldUpdate: () => setMediaShouldUpdate,
  setupMediaListeners: () => setupMediaListeners,
  useMedia: () => useMedia
});
module.exports = __toCommonJS(useMedia_exports);
var import_constants = require("@tamagui/constants"), import_react = __toESM(require("react")), import_config = require("../config"), import_matchMedia = require("../helpers/matchMedia"), import_pseudoDescriptors = require("../helpers/pseudoDescriptors"), import_useDisableSSR = require("./useDisableSSR"), mediaState = (
  // development only safeguard
  process.env.NODE_ENV === "development" ? new Proxy({}, {
    get(target, key) {
      if (typeof key == "string" && key[0] === "$" && // dont error on $$typeof
      key[1] !== "$")
        throw new Error(`Access mediaState should not use "$": ${key}`);
      return Reflect.get(target, key);
    }
  }) : {}
), mediaQueryConfig = {}, getMedia = function() {
  return mediaState;
}, mediaKeys = /* @__PURE__ */ new Set(), mediaKeyRegex = /\$(platform|theme|group)-/, isMediaKey = function(key) {
  if (mediaKeys.has(key)) return !0;
  if (key[0] === "$") {
    var match = key.match(mediaKeyRegex);
    if (match) return match[1];
  }
  return !1;
}, initState, defaultMediaImportance = Object.keys(import_pseudoDescriptors.pseudoDescriptors).length, mediaKeysOrdered, getMediaKeyImportance = function(key) {
  if (process.env.NODE_ENV === "development" && key[0] === "$")
    throw new Error("use short key");
  var conf = (0, import_config.getConfig)();
  return conf.settings.mediaPropOrder ? defaultMediaImportance : mediaKeysOrdered.indexOf(key) + 100;
}, dispose = /* @__PURE__ */ new Set(), mediaVersion = 0, configureMedia = function(config) {
  var { media } = config, mediaQueryDefaultActive = (0, import_config.getSetting)("mediaQueryDefaultActive");
  if (media) {
    mediaVersion++;
    for (var key in media)
      mediaState[key] = (mediaQueryDefaultActive == null ? void 0 : mediaQueryDefaultActive[key]) || !1, mediaKeys.add(`$${key}`);
    Object.assign(mediaQueryConfig, media), initState = {
      ...mediaState
    }, mediaKeysOrdered = Object.keys(media), setupMediaListeners();
  }
};
function unlisten() {
  dispose.forEach(function(cb) {
    return cb();
  }), dispose.clear();
}
var setupVersion = -1;
function setupMediaListeners() {
  var _loop = function(key2) {
    var str = mediaObjectToString(mediaQueryConfig[key2], key2), getMatch = function() {
      return (0, import_matchMedia.matchMedia)(str);
    }, match = getMatch();
    if (!match)
      throw new Error("\u26A0\uFE0F No match");
    match.addListener(update), dispose.add(function() {
      match.removeListener(update);
    }), update();
    function update() {
      var next = !!getMatch().matches;
      next !== mediaState[key2] && (mediaState = {
        ...mediaState,
        [key2]: next
      }, updateCurrentState());
    }
  };
  if (!(import_constants.isWeb && import_constants.isServer) && !process.env.IS_STATIC && setupVersion !== mediaVersion) {
    setupVersion = mediaVersion, unlisten();
    for (var key in mediaQueryConfig) _loop(key);
  }
}
var listeners = /* @__PURE__ */ new Set(), flushing = !1, flushVersion = -1;
function updateCurrentState() {
  flushing && flushVersion === mediaVersion || (flushVersion = mediaVersion, flushing = !0, Promise.resolve().then(function() {
    flushing = !1, listeners.forEach(function(cb) {
      return cb(mediaState);
    });
  }));
}
var States = /* @__PURE__ */ new WeakMap();
function setMediaShouldUpdate(ref, enabled, keys) {
  var cur = States.get(ref);
  (!cur || cur.enabled !== enabled || keys) && States.set(ref, {
    ...cur,
    enabled,
    keys
  });
}
function subscribe(subscriber) {
  return listeners.add(subscriber), function() {
    listeners.delete(subscriber);
  };
}
var CurrentKeysMap = /* @__PURE__ */ new WeakMap();
function useMedia(cc, debug) {
  var disableSSR = (0, import_config.getSetting)("disableSSR") || (0, import_useDisableSSR.getDisableSSR)(cc), initialState = disableSSR || !import_constants.isWeb ? mediaState : initState, [state, setState] = import_react.default.useState(initialState);
  CurrentKeysMap.get(setState) || CurrentKeysMap.set(setState, /* @__PURE__ */ new Set());
  var currentKeys = CurrentKeysMap.get(setState);
  function getSnapshot(cur) {
    if (!currentKeys) return cur;
    var _iteratorNormalCompletion = !0, _didIteratorError = !1, _iteratorError = void 0;
    try {
      for (var _iterator = currentKeys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = !0) {
        var key = _step.value;
        if (mediaState[key] !== cur[key])
          return process.env.NODE_ENV === "development" && debug && console.warn("useMedia()\u270D\uFE0F", key, cur[key], ">", mediaState[key]), mediaState;
      }
    } catch (err) {
      _didIteratorError = !0, _iteratorError = err;
    } finally {
      try {
        !_iteratorNormalCompletion && _iterator.return != null && _iterator.return();
      } finally {
        if (_didIteratorError)
          throw _iteratorError;
      }
    }
    return cur;
  }
  var isRendering = !0, isInitialState = state === initialState;
  return (0, import_constants.useIsomorphicLayoutEffect)(function() {
    isRendering = !1;
  }), (0, import_constants.useIsomorphicLayoutEffect)(function() {
    var update = function() {
      return setState(function(prev) {
        var next = getSnapshot(prev);
        return next;
      });
    };
    update();
    var tm = setTimeout(function() {
      currentKeys.size && update();
    }), dispose2 = subscribe(update);
    return function() {
      dispose2(), clearTimeout(tm);
    };
  }, [
    setState
  ]), new Proxy(state, {
    get(_, key) {
      if (isRendering && !disableMediaTouch && typeof key == "string") {
        currentKeys.add(key);
        var shouldUpdate = state[key] !== mediaState[key];
        if (shouldUpdate && (process.env.NODE_ENV === "development" && debug && console.info("useMedia() TOUCH", key), !isInitialState)) {
          var next = getSnapshot(state);
          next !== state && setState(next);
        }
      }
      return Reflect.get(state, key);
    }
  });
}
var disableMediaTouch = !1;
function _disableMediaTouch(val) {
  disableMediaTouch = val;
}
function getMediaState(mediaGroups, layout) {
  disableMediaTouch = !0;
  var res;
  try {
    res = Object.fromEntries([
      ...mediaGroups
    ].map(function(mediaKey) {
      return [
        mediaKey,
        mediaKeyMatch(mediaKey, layout)
      ];
    }));
  } finally {
    disableMediaTouch = !1;
  }
  return res;
}
var getMediaImportanceIfMoreImportant = function(mediaKey, key, importancesUsed, isSizeMedia) {
  var importance = isSizeMedia && !(0, import_config.getSetting)("mediaPropOrder") ? getMediaKeyImportance(mediaKey) : defaultMediaImportance;
  return !importancesUsed[key] || importance > importancesUsed[key] ? importance : null;
};
function camelToHyphen(str) {
  return str.replace(/[A-Z]/g, function(m) {
    return `-${m.toLowerCase()}`;
  }).toLowerCase();
}
var cache = /* @__PURE__ */ new WeakMap(), cachedMediaKeyToQuery = {};
function mediaObjectToString(query, key) {
  if (typeof query == "string")
    return query;
  if (cache.has(query))
    return cache.get(query);
  var res = Object.entries(query).map(function(param) {
    var [feature, value] = param;
    return feature = camelToHyphen(feature), typeof value == "string" ? `(${feature}: ${value})` : (typeof value == "number" && /[height|width]$/.test(feature) && (value = `${value}px`), `(${feature}: ${value})`);
  }).join(" and ");
  return key && (cachedMediaKeyToQuery[key] = res), cache.set(query, res), res;
}
function mediaKeyToQuery(key) {
  return cachedMediaKeyToQuery[key] || mediaObjectToString(mediaQueryConfig[key], key);
}
function mediaKeyMatch(key, dimensions) {
  var mediaQueries = mediaQueryConfig[key], result = Object.keys(mediaQueries).every(function(query) {
    var expectedVal = +mediaQueries[query], isMax = query.startsWith("max"), isWidth = query.endsWith("Width"), givenVal = dimensions[isWidth ? "width" : "height"];
    return isMax ? givenVal < expectedVal : givenVal > expectedVal;
  });
  return result;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  _disableMediaTouch,
  configureMedia,
  getMedia,
  getMediaImportanceIfMoreImportant,
  getMediaKeyImportance,
  getMediaState,
  isMediaKey,
  mediaKeyMatch,
  mediaKeyToQuery,
  mediaKeys,
  mediaObjectToString,
  mediaQueryConfig,
  mediaState,
  setMediaShouldUpdate,
  setupMediaListeners,
  useMedia
});
//# sourceMappingURL=useMedia.js.map
