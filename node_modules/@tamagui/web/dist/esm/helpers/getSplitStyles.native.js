import { isAndroid, isClient, isServer, isWeb, useIsomorphicLayoutEffect } from "@tamagui/constants";
import { StyleObjectIdentifier, StyleObjectProperty, StyleObjectPseudo, stylePropsText, stylePropsTransform, tokenCategories, validPseudoKeys, validStyles } from "@tamagui/helpers";
import React from "react";
import { getConfig, getFont } from "../config";
import "../constants/accessibilityDirectMap";
import "../constants/constants";
import { isDevTools } from "../constants/isDevTools";
import { getMediaImportanceIfMoreImportant, mediaState as globalMediaState, isMediaKey, mediaKeyMatch, mediaQueryConfig } from "../hooks/useMedia";
import { createMediaStyle } from "./createMediaStyle";
import { fixStyles } from "./expandStyles";
import { getGroupPropParts } from "./getGroupPropParts";
import { getStyleAtomic, getStylesAtomic, styleToCSS } from "./getStylesAtomic";
import "./insertStyleRule";
import { isActivePlatform } from "./isActivePlatform";
import { isActiveTheme } from "./isActiveTheme";
import { log } from "./log";
import { normalizeValueWithProperty } from "./normalizeValueWithProperty";
import { getPropMappedFontFamily, propMapper } from "./propMapper";
import { pseudoDescriptors, pseudoPriorities } from "./pseudoDescriptors";
import { skipProps } from "./skipProps";
import { sortString } from "./sortString";
import { transformsToString } from "./transformsToString";
var consoleGroupCollapsed = isWeb ? console.groupCollapsed : console.info, conf, PROP_SPLIT = "-";
function isValidStyleKey(key, staticConfig) {
  var _staticConfig_accept, validStyleProps = staticConfig.validStyles || (staticConfig.isText || staticConfig.isInput ? stylePropsText : validStyles);
  return validStyleProps[key] || ((_staticConfig_accept = staticConfig.accept) === null || _staticConfig_accept === void 0 ? void 0 : _staticConfig_accept[key]);
}
var getSplitStyles = function(props, staticConfig, theme, themeName, componentState, styleProps, parentSplitStyles, context, elementType, debug) {
  conf = conf || getConfig(), isWeb && styleProps.isAnimated && conf.animations.isReactNative && !styleProps.noNormalize && (styleProps.noNormalize = "values");
  var { shorthands } = conf, { isHOC, isText, isInput, variants, isReactNative, inlineProps, inlineWhenUnflattened, parentStaticConfig, acceptsClassName } = staticConfig, viewProps = {}, mediaState = styleProps.mediaState || globalMediaState, usedKeys = {}, shouldDoClasses = acceptsClassName && isWeb && !styleProps.noClass, rulesToInsert = void 0, classNames = {}, transforms = {}, pseudos = null, space = props.space, hasMedia = !1, dynamicThemeAccess, pseudoGroups, mediaGroups, className = props.className || "", mediaStylesSeen = 0, styleState = {
    classNames,
    conf,
    props,
    styleProps,
    componentState,
    staticConfig,
    style: null,
    theme,
    usedKeys,
    viewProps,
    context,
    debug
  };
  process.env.NODE_ENV === "development" && debug && debug !== "profile" && isClient && (consoleGroupCollapsed("getSplitStyles (collapsed)"), log({
    props,
    staticConfig,
    shouldDoClasses,
    styleProps,
    rulesToInsert,
    componentState,
    styleState,
    theme: {
      ...theme
    }
  }), console.groupEnd());
  var { asChild } = props, { accept } = staticConfig, { noSkip, disableExpandShorthands, noExpand } = styleProps, { webContainerType } = conf.settings, parentVariants = parentStaticConfig?.variants;
  for (var keyOg in props) {
    var _loop = function(i2) {
      var _parentStaticConfig_variants;
      if (expanded) {
        var [k, v] = expanded[i2];
        key = k, val = v;
      }
      if (val == null || key in usedKeys) return "continue";
      if (isPseudo = key in validPseudoKeys, isMedia = !isPseudo && !isValidStyleKeyInit && isMediaKey(key), isMediaOrPseudo1 = !!(isMedia || isPseudo), isVariant = variants && key in variants, inlineProps?.has(key) || process.env.IS_STATIC === "is_static" && inlineWhenUnflattened?.has(key)) {
        var _props_key;
        viewProps[key] = (_props_key = props[key]) !== null && _props_key !== void 0 ? _props_key : val;
      }
      var shouldPassThrough2 = styleProps.noExpand && isPseudo || isHOC && (isMediaOrPseudo1 || (parentStaticConfig == null || (_parentStaticConfig_variants = parentStaticConfig.variants) === null || _parentStaticConfig_variants === void 0 ? void 0 : _parentStaticConfig_variants[keyInit]));
      if (shouldPassThrough2)
        return passDownProp(viewProps, key, val, isMediaOrPseudo1), process.env.NODE_ENV === "development" && debug === "verbose" && (consoleGroupCollapsed(` - passing down prop ${key}`), log({
          val,
          after: {
            ...viewProps[key]
          }
        }), console.groupEnd()), "continue";
      if (isPseudo) {
        if (!val) return "continue";
        var pseudoStyleObject = getSubStyle(styleState, key, val, styleProps.noClass), descriptor = pseudoDescriptors[key], isEnter = key === "enterStyle", isExit = key === "exitStyle";
        if (!descriptor)
          return "continue";
        if (!shouldDoClasses || process.env.IS_STATIC === "is_static") {
          var _pseudos, _key;
          if (pseudos || (pseudos = {}), (_pseudos = pseudos)[_key = key] || (_pseudos[_key] = {}), process.env.IS_STATIC === "is_static")
            return Object.assign(pseudos[key], pseudoStyleObject), "continue";
        }
        if (shouldDoClasses && !isExit) {
          var pseudoStyles = getStyleAtomic(pseudoStyleObject, descriptor);
          process.env.NODE_ENV === "development" && debug === "verbose" && (consoleGroupCollapsed("pseudo (classes)", key), log({
            pseudoStyleObject,
            pseudoStyles
          }), console.groupEnd());
          var _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
          try {
            for (var _iterator2 = pseudoStyles[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = !0) {
              var psuedoStyle = _step2.value, fullKey = `${psuedoStyle[StyleObjectProperty]}${PROP_SPLIT}${descriptor.name}`;
              fullKey in usedKeys || (addStyleToInsertRules(rulesToInsert, psuedoStyle), mergeClassName(transforms, classNames, fullKey, psuedoStyle[StyleObjectIdentifier], isMediaOrPseudo1, !0));
            }
          } catch (err) {
            _didIteratorError2 = !0, _iteratorError2 = err;
          } finally {
            try {
              !_iteratorNormalCompletion2 && _iterator2.return != null && _iterator2.return();
            } finally {
              if (_didIteratorError2)
                throw _iteratorError2;
            }
          }
        }
        if (!shouldDoClasses || isExit || isEnter) {
          var descriptorKey = descriptor.stateKey || descriptor.name, isDisabled = componentState[descriptorKey] === !1;
          isExit && (isDisabled = !styleProps.isExiting), isEnter && componentState.unmounted === !1 && (isDisabled = !0), process.env.NODE_ENV === "development" && debug === "verbose" && (consoleGroupCollapsed("pseudo", key, {
            isDisabled
          }), log({
            pseudoStyleObject,
            isDisabled,
            descriptor,
            componentState
          }), console.groupEnd());
          var importance = descriptor.priority;
          for (var pkey in pseudoStyleObject) {
            var val12 = pseudoStyleObject[pkey];
            if (isDisabled)
              applyDefaultStyle(pkey, styleState);
            else {
              var curImportance = usedKeys[pkey] || 0, shouldMerge = importance >= curImportance;
              if (shouldMerge) {
                var _pseudos1, _key1;
                pseudos || (pseudos = {}), (_pseudos1 = pseudos)[_key1 = key] || (_pseudos1[_key1] = {}), pseudos[key][pkey] = val12, mergeStyle(styleState, pkey, val12);
              }
              process.env.NODE_ENV === "development" && debug === "verbose" && log("    subKey", pkey, shouldMerge, {
                importance,
                curImportance,
                pkey,
                val: val12
              });
            }
          }
          if (!isDisabled)
            for (var key12 in val) {
              var k1 = shorthands[key12] || key12;
              usedKeys[k1] = Math.max(importance, usedKeys[k1] || 0);
            }
        }
        return "continue";
      }
      if (isMedia) {
        if (!val) return "continue";
        var hasSpace = val.space, mediaKeyShort = key.slice(isMedia == "theme" ? 7 : 1);
        if (hasMedia || (hasMedia = !0), (hasSpace || !shouldDoClasses || styleProps.willBeAnimated) && (typeof hasMedia != "object" && (hasMedia = {}), hasMedia[mediaKeyShort] = !0), isMedia === "platform" && !isActivePlatform(key))
          return "continue";
        if (process.env.NODE_ENV === "development" && debug === "verbose" && log(`  \u{1F4FA} ${key}`, {
          key,
          val,
          props,
          shouldDoClasses,
          acceptsClassName,
          componentState,
          mediaState
        }), shouldDoClasses) {
          var mediaStyle = getSubStyle(styleState, key, val, !1);
          if (hasSpace && (delete mediaStyle.space, mediaState[mediaKeyShort])) {
            var importance1 = getMediaImportanceIfMoreImportant(mediaKeyShort, "space", usedKeys, !0);
            importance1 && (space = val.space, usedKeys.space = importance1, process.env.NODE_ENV === "development" && debug === "verbose" && log(`Found more important space for current media ${mediaKeyShort}: ${val} (importance: ${importance1})`));
          }
          var mediaStyles = getStylesAtomic(mediaStyle), priority = mediaStylesSeen;
          mediaStylesSeen += 1;
          var _iteratorNormalCompletion12 = !0, _didIteratorError12 = !1, _iteratorError12 = void 0;
          try {
            for (var _iterator12 = mediaStyles[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = !0) {
              var style3 = _step12.value, property = style3[StyleObjectProperty], isSubStyle = property[0] === "$";
              if (!(isSubStyle && !isActivePlatform(property))) {
                var out = createMediaStyle(style3, mediaKeyShort, mediaQueryConfig, isMedia, !1, priority);
                process.env.NODE_ENV === "development" && debug === "verbose" && log("\u{1F4FA} media style:", out);
                var subKey = isSubStyle ? style3[2] : "", fullKey1 = `${style3[StyleObjectProperty]}${subKey}${PROP_SPLIT}${mediaKeyShort}${style3[StyleObjectPseudo] || ""}`;
                fullKey1 in usedKeys || (addStyleToInsertRules(rulesToInsert, out), mergeClassName(transforms, classNames, fullKey1, out[StyleObjectIdentifier], !0, !0));
              }
            }
          } catch (err) {
            _didIteratorError12 = !0, _iteratorError12 = err;
          } finally {
            try {
              !_iteratorNormalCompletion12 && _iterator12.return != null && _iterator12.return();
            } finally {
              if (_didIteratorError12)
                throw _iteratorError12;
            }
          }
        } else {
          let mergeMediaStyle2 = function(key5, val3) {
            var _styleState4;
            (_styleState4 = styleState).style || (_styleState4.style = {});
            var didMerge = mergeMediaByImportance(styleState, mediaKeyShort, key5, val3, usedKeys, mediaState[mediaKeyShort], importanceBump, debug);
            didMerge && key5 === "fontFamily" && (styleState.fontFamily = mediaStyle1.fontFamily);
          };
          var mergeMediaStyle = mergeMediaStyle2, isThemeMedia = isMedia === "theme", isGroupMedia = isMedia === "group", isPlatformMedia = isMedia === "platform";
          if (!isThemeMedia && !isPlatformMedia && !isGroupMedia) {
            if (!mediaState[mediaKeyShort])
              return process.env.NODE_ENV === "development" && debug === "verbose" && log(`  \u{1F4FA} \u274C DISABLED ${mediaKeyShort}`), "continue";
            process.env.NODE_ENV === "development" && debug === "verbose" && log(`  \u{1F4FA} \u2705 ENABLED ${mediaKeyShort}`);
          }
          var mediaStyle1 = getSubStyle(styleState, key, val, !0), importanceBump = 0;
          if (isThemeMedia) {
            if (dynamicThemeAccess = !0, !(themeName === mediaKeyShort || themeName.startsWith(mediaKeyShort)))
              return "continue";
          } else if (isGroupMedia) {
            var _componentState_group, groupInfo = getGroupPropParts(mediaKeyShort), groupName = groupInfo.name, groupContext = context?.groups.state[groupName];
            if (!groupContext)
              return process.env.NODE_ENV === "development" && debug && log(`No parent with group prop, skipping styles: ${groupName}`), "continue";
            var groupPseudoKey = groupInfo.pseudo, groupMediaKey = groupInfo.media, componentGroupState = (_componentState_group = componentState.group) === null || _componentState_group === void 0 ? void 0 : _componentState_group[groupName];
            if (groupMediaKey) {
              mediaGroups || (mediaGroups = /* @__PURE__ */ new Set()), mediaGroups.add(groupMediaKey);
              var mediaState1 = componentGroupState?.media, isActive = mediaState1?.[groupMediaKey];
              if (!mediaState1 && groupContext.layout && (isActive = mediaKeyMatch(groupMediaKey, groupContext.layout)), process.env.NODE_ENV === "development" && debug === "verbose" && log(` \u{1F3D8}\uFE0F GROUP media ${groupMediaKey} active? ${isActive}`), !isActive) {
                for (var pkey1 in mediaStyle1)
                  applyDefaultStyle(pkey1, styleState);
                return "continue";
              }
              importanceBump = 2;
            }
            if (groupPseudoKey) {
              pseudoGroups || (pseudoGroups = /* @__PURE__ */ new Set()), pseudoGroups.add(groupName);
              var componentGroupPseudoState = (componentGroupState || // fallback to context initially
              context.groups.state[groupName]).pseudo, isActive1 = componentGroupPseudoState?.[groupPseudoKey], priority1 = pseudoPriorities[groupPseudoKey];
              if (process.env.NODE_ENV === "development" && debug === "verbose" && log(` \u{1F3D8}\uFE0F GROUP pseudo ${groupMediaKey} active? ${isActive1}, priority ${priority1}`), !isActive1) {
                for (var pkey2 in mediaStyle1)
                  applyDefaultStyle(pkey2, styleState);
                return "continue";
              }
              importanceBump = priority1;
            }
          }
          for (var subKey1 in mediaStyle1) {
            if (subKey1 === "space") {
              space = valInit.space;
              continue;
            }
            if (subKey1[0] === "$") {
              if (!isActivePlatform(subKey1) || !isActiveTheme(subKey1, themeName)) continue;
              for (var subSubKey in mediaStyle1[subKey1])
                mergeMediaStyle2(subSubKey, mediaStyle1[subKey1][subSubKey]);
            } else
              mergeMediaStyle2(subKey1, mediaStyle1[subKey1]);
          }
        }
        return "continue";
      }
      if (key === "pointerEvents")
        return viewProps[key] = val, "continue";
      if (
        // is HOC we can just pass through the styles as props
        // this fixes issues where style prop got merged with wrong priority
        !isHOC && (isValidStyleKey(key, staticConfig) || isAndroid && key === "elevation")
      )
        return mergeStyle(styleState, key, val), "continue";
      if (!isVariant) {
        if (styleProps.styledContextProps && key in styleProps.styledContextProps)
          return "continue";
        viewProps[key] = val;
      }
    }, keyInit = keyOg, valInit = props[keyInit];
    if (!(process.env.NODE_ENV === "test" && keyInit === "jestAnimatedStyle")) {
      if (process.env.NODE_ENV === "development" && debug === "profile" && time`prop-${keyInit}`, accept) {
        var accepted = accept[keyInit];
        if ((accepted === "style" || accepted === "textStyle") && valInit && typeof valInit == "object") {
          viewProps[keyInit] = getSubStyle(styleState, keyInit, valInit, styleProps.noClass);
          continue;
        }
      }
      if (process.env.NODE_ENV === "development" && debug === "verbose" && console.groupEnd(), disableExpandShorthands || keyInit in shorthands && (keyInit = shorthands[keyInit]), keyInit !== "className" && !(keyInit in usedKeys)) {
        if (keyInit in skipProps && !noSkip && !isHOC) {
          if (keyInit === "group" && 0)
            var identifier, containerType, containerCSS;
          continue;
        }
        var valInitType = typeof valInit, isValidStyleKeyInit = isValidStyleKey(keyInit, staticConfig);
        if (0) {
          if (staticConfig.isReactNative && keyInit.startsWith("data-"))
            var _viewProps, _dataSet;
          if (isValidStyleKeyInit && valInitType === "string" && valInit[0] === "_") {
            var isValidClassName, isMediaOrPseudo;
            if ((isValidClassName || isMediaOrPseudo) && !shouldDoClasses)
              var _styleState;
          }
        }
        if (!isValidStyleKeyInit) {
          if (!isAndroid && keyInit === "elevationAndroid")
            continue;
          if (keyInit === "userSelect")
            keyInit = "selectable", valInit = valInit !== "none";
          else if (keyInit.startsWith("data-"))
            continue;
        }
        if (keyInit === "dataSet") {
          for (var keyInit1 in valInit)
            viewProps[`data-${hyphenate(keyInit1)}`] = valInit[keyInit1];
          continue;
        }
        if (0 && !noExpand)
          var didUseKeyInit;
        var isShorthand = keyInit in shorthands, isVariant = !isValidStyleKeyInit && variants && keyInit in variants, isStyleLikeKey = isShorthand || isValidStyleKeyInit || isVariant, isPseudo = keyInit in validPseudoKeys, isMedia = !isStyleLikeKey && !isPseudo && isMediaKey(keyInit), isMediaOrPseudo1 = !!(isMedia || isPseudo);
        if (isMediaOrPseudo1 && keyInit.startsWith("$group-")) {
          var parts = keyInit.split("-");
          if (
            // check if its actually a simple group selector to avoid breaking selectors
            parts.length === 2 || parts.length === 3 && pseudoPriorities[parts[parts.length - 1]]
          ) {
            var name = parts[1];
            context?.groups.subscribe && !context?.groups.state[name] && (keyInit = keyInit.replace("$group-", "$group-true-"));
          }
        }
        var isStyleProp = isValidStyleKeyInit || isMediaOrPseudo1 || isVariant && !noExpand || isShorthand;
        if (!(isStyleProp && (asChild === "except-style" || asChild === "except-style-web"))) {
          var shouldPassProp = !isStyleProp && isHOC || // is in parent variants
          isHOC && parentVariants && keyInit in parentVariants || inlineProps?.has(keyInit), parentVariant = parentVariants?.[keyInit], isHOCShouldPassThrough = !!(isHOC && (isShorthand || isValidStyleKeyInit || isMediaOrPseudo1 || parentVariant || keyInit in skipProps)), shouldPassThrough = shouldPassProp || isHOCShouldPassThrough;
          if (process.env.NODE_ENV === "development" && debug === "verbose" && (console.groupEnd(), console.groupEnd(), consoleGroupCollapsed(`  \u{1F511} ${keyOg}${keyInit !== keyOg ? ` (shorthand for ${keyInit})` : ""} ${shouldPassThrough ? "(pass)" : ""}`), log({
            isVariant,
            valInit,
            shouldPassProp
          }), isClient && log({
            variants,
            variant: variants?.[keyInit],
            isVariant,
            isHOCShouldPassThrough,
            parentStaticConfig
          })), shouldPassThrough && (passDownProp(viewProps, keyInit, valInit, isMediaOrPseudo1), !isVariant)) {
            process.env.NODE_ENV === "development" && debug === "verbose" && console.groupEnd();
            continue;
          }
          if (!noSkip && keyInit in skipProps) {
            process.env.NODE_ENV === "development" && debug === "verbose" && console.groupEnd();
            continue;
          }
          (isText || isInput) && valInit && (keyInit === "fontFamily" || keyInit === shorthands.fontFamily) && valInit in conf.fontsParsed && (styleState.fontFamily = valInit);
          var avoidPropMap = isMediaOrPseudo1 || !isVariant && !isValidStyleKeyInit, expanded = avoidPropMap ? null : propMapper(keyInit, valInit, styleState);
          if (!avoidPropMap) {
            if (!expanded) continue;
            var next = getPropMappedFontFamily(expanded);
            next && (styleState.fontFamily = next);
          }
          if (process.env.NODE_ENV === "development" && debug === "verbose") {
            consoleGroupCollapsed("  \u{1F4A0} expanded", keyInit, valInit);
            try {
              !isServer && isDevTools && (log({
                expanded,
                styleProps,
                componentState,
                isVariant,
                variant: variants?.[keyInit],
                shouldPassProp,
                isHOCShouldPassThrough,
                usedKeys: {
                  ...usedKeys
                }
              }), globalThis.tamaguiAvoidTracking = !0, log("expanded", expanded, `
usedKeys`, {
                ...usedKeys
              }, `
current`, {
                ...styleState.style
              }), globalThis.tamaguiAvoidTracking = !1);
            } catch {
            }
            console.groupEnd();
          }
          for (var key = keyInit, val = valInit, max = expanded ? expanded.length : 1, i = 0; i < max; i++) _loop(i);
          if (process.env.NODE_ENV === "development" && debug === "verbose") {
            try {
              log(" \u2714\uFE0F expand complete", keyInit), log("style", {
                ...styleState.style
              }), log("transforms", {
                ...transforms
              }), log("viewProps", {
                ...viewProps
              });
            } catch {
            }
            console.groupEnd();
          }
        }
      }
    }
  }
  process.env.NODE_ENV === "development" && debug === "profile" && time`split-styles-propsend`;
  var avoidNormalize = styleProps.noNormalize === !1;
  if (!avoidNormalize) {
    if (styleState.style && (fixStyles(styleState.style), isWeb && !isReactNative && styleToCSS(styleState.style)), styleState.flatTransforms) {
      var _styleState1;
      (_styleState1 = styleState).style || (_styleState1.style = {}), Object.entries(styleState.flatTransforms).sort(function(param, param1) {
        var [a] = param, [b] = param1;
        return sortString(a, b);
      }).forEach(function(param) {
        var [key5, val3] = param;
        mergeTransform(styleState.style, key5, val3, !0);
      });
    }
    if (parentSplitStyles) {
      if (0 && shouldDoClasses)
        for (var key1 in parentSplitStyles.classNames)
          var val1;
      if (!shouldDoClasses)
        for (var key2 in parentSplitStyles.style) {
          var _styleState2;
          key2 in classNames || styleState.style && key2 in styleState.style || ((_styleState2 = styleState).style || (_styleState2.style = {}), styleState.style[key2] = parentSplitStyles.style[key2]);
        }
    }
  }
  if (0)
    var _styleState_style, shouldStringifyTransforms;
  if (0) {
    if (styleState.style && shouldDoClasses) {
      var retainedStyles, shouldRetain;
      if (!styleState.style.$$css) {
        var atomic, _iteratorNormalCompletion, _didIteratorError, _iteratorError;
        try {
          for (var _iterator, _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = !0)
            var atomicStyle, _props_animateOnly, _props_animateOnly1, key3, value, identifier1, isAnimatedAndAnimateOnly, nonAnimatedAnimateOnly;
        } catch (err) {
        } finally {
          try {
          } finally {
          }
        }
      }
      if (transforms)
        for (var namespace in transforms) {
          var hash, val2, identifier2;
          if (isClient && !insertedTransforms[identifier2])
            var rule;
        }
    }
    if (isReactNative) {
      if (viewProps.tabIndex === 0)
        var _viewProps1, _accessible;
    } else if (viewProps.tabIndex == null)
      var _viewProps_focusable, isFocusable, role;
  }
  var styleProp = props.style;
  if (styleProp)
    if (isHOC)
      viewProps.style = normalizeStyle(styleProp);
    else
      for (var isArray = Array.isArray(styleProp), len = isArray ? styleProp.length : 1, i1 = 0; i1 < len; i1++) {
        var style = isArray ? styleProp[i1] : styleProp;
        if (style)
          if (style.$$css)
            Object.assign(styleState.classNames, style);
          else {
            var _styleState3;
            (_styleState3 = styleState).style || (_styleState3.style = {}), Object.assign(styleState.style, normalizeStyle(style));
          }
      }
  var style1 = styleState.style;
  if (style1?.fontFamily) {
    var _getFont, faceInfo = (_getFont = getFont(style1.fontFamily)) === null || _getFont === void 0 ? void 0 : _getFont.face;
    if (faceInfo) {
      var _faceInfo_style_fontWeight_, _faceInfo_style_fontWeight, overrideFace = (_faceInfo_style_fontWeight = faceInfo[style1.fontWeight]) === null || _faceInfo_style_fontWeight === void 0 || (_faceInfo_style_fontWeight_ = _faceInfo_style_fontWeight[style1.fontStyle || "normal"]) === null || _faceInfo_style_fontWeight_ === void 0 ? void 0 : _faceInfo_style_fontWeight_.val;
      overrideFace && (style1.fontFamily = overrideFace, styleState.fontFamily = overrideFace, delete style1.fontWeight, delete style1.fontStyle);
    }
    process.env.NODE_ENV === "development" && debug && debug !== "profile" && log(`Found fontFamily native: ${style1.fontFamily}`, faceInfo);
  }
  process.env.NODE_ENV === "development" && debug === "profile" && time`split-styles-pre-result`;
  var result = {
    space,
    hasMedia,
    fontFamily: styleState.fontFamily,
    viewProps,
    style: styleState.style,
    pseudos,
    classNames,
    rulesToInsert,
    dynamicThemeAccess,
    pseudoGroups,
    mediaGroups
  }, asChildExceptStyleLike = asChild === "except-style" || asChild === "except-style-web";
  if (!asChildExceptStyleLike) {
    var style2 = styleState.style;
    if (0) {
      var _staticConfig_defaultProps, fontFamily, fontFamilyClassName, groupClassName, componentNameFinal, componentClassName, classList, finalClassName;
      if (!styleProps.noMergeStyle) {
        if (!(styleProps.isAnimated && !conf.animations.supportsCSSVars && isReactNative)) {
          if (isReactNative) {
            var cnStyles, _iteratorNormalCompletion1, _didIteratorError1, _iteratorError1;
            try {
              for (var _iterator1, _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = !0)
                var name1;
            } catch (err) {
            } finally {
              try {
              } finally {
              }
            }
          }
        }
      }
    } else
      style2 && !styleProps.noMergeStyle && (viewProps.style = style2);
  }
  if (process.env.NODE_ENV === "development" && debug === "verbose" && isDevTools) {
    consoleGroupCollapsed("\u{1F539} getSplitStyles ===>");
    try {
      var logs = {
        ...result,
        className,
        componentState,
        transforms,
        viewProps,
        rulesToInsert,
        parentSplitStyles
      };
      for (var key4 in logs)
        log(key4, logs[key4]);
    } catch {
    }
    console.groupEnd();
  }
  return process.env.NODE_ENV === "development" && debug === "profile" && time`split-styles-done`, result;
};
function mergeClassName(transforms, classNames, key, val) {
  var isMediaOrPseudo = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !1, isInsertingNow = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : !1;
  if (0 && !isInsertingNow && val[0] === "_" && val.startsWith("_transform-"))
    var _transforms, _ns, ns, transform;
}
function mergeStyle(styleState, key, val) {
  var disableNormalize = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1, { classNames, viewProps, usedKeys, styleProps, staticConfig } = styleState;
  if (isWeb && val?.[0] === "_") {
    var _usedKeys, _key;
    classNames[key] = val, (_usedKeys = usedKeys)[_key = key] || (_usedKeys[_key] = 1);
  } else if (key in stylePropsTransform) {
    var _styleState;
    (_styleState = styleState).flatTransforms || (_styleState.flatTransforms = {}), styleState.flatTransforms[key] = val;
  } else {
    var shouldNormalize = isWeb && !disableNormalize && !styleProps.noNormalize, out = shouldNormalize ? normalizeValueWithProperty(val, key) : val;
    if (
      // accept is for props not styles
      staticConfig.accept && key in staticConfig.accept
    )
      viewProps[key] = out;
    else {
      var _styleState1;
      (_styleState1 = styleState).style || (_styleState1.style = {}), styleState.style[key] = out;
    }
  }
}
var getSubStyle = function(styleState, subKey, styleIn, avoidMergeTransform) {
  var { staticConfig, conf: conf2, styleProps } = styleState, styleOut = {};
  for (var key in styleIn) {
    var val = styleIn[key];
    key = conf2.shorthands[key] || key;
    var expanded = propMapper(key, val, styleState);
    if (!(!expanded || !staticConfig.isHOC && key in skipProps && !styleProps.noSkip)) {
      var _iteratorNormalCompletion = !0, _didIteratorError = !1, _iteratorError = void 0;
      try {
        for (var _iterator = expanded[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = !0) {
          var [skey, sval] = _step.value;
          skey in validPseudoKeys && (sval = getSubStyle(styleState, skey, sval, avoidMergeTransform)), !avoidMergeTransform && skey in stylePropsTransform ? mergeTransform(styleOut, skey, sval) : styleOut[skey] = styleProps.noNormalize ? sval : normalizeValueWithProperty(sval, key);
        }
      } catch (err) {
        _didIteratorError = !0, _iteratorError = err;
      } finally {
        try {
          !_iteratorNormalCompletion && _iterator.return != null && _iterator.return();
        } finally {
          if (_didIteratorError)
            throw _iteratorError;
        }
      }
    }
  }
  return styleProps.noNormalize || fixStyles(styleOut), styleOut;
}, useInsertEffectCompat = isWeb ? React.useInsertionEffect || useIsomorphicLayoutEffect : function() {
}, useSplitStyles = function(a, b, c, d, e, f, g, h, i, j) {
  conf = conf || getConfig();
  var res = getSplitStyles(a, b, c, d, e, f, g, h, i, j);
  return res;
};
function addStyleToInsertRules(rulesToInsert, styleObject) {
  if (0)
    var identifier;
}
var defaultColor = process.env.TAMAGUI_DEFAULT_COLOR || "rgba(0,0,0,0)", animatableDefaults = {
  ...Object.fromEntries(Object.entries(tokenCategories.color).map(function(param) {
    var [k, v] = param;
    return [
      k,
      defaultColor
    ];
  })),
  opacity: 1,
  scale: 1,
  rotate: "0deg",
  rotateY: "0deg",
  rotateX: "0deg",
  x: 0,
  y: 0,
  borderRadius: 0
}, lowercaseHyphenate = function(match) {
  return `-${match.toLowerCase()}`;
}, hyphenate = function(str) {
  return str.replace(/[A-Z]/g, lowercaseHyphenate);
}, mergeTransform = function(obj, key, val) {
  var backwards = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1, _obj;
  typeof obj.transform != "string" && ((_obj = obj).transform || (_obj.transform = []), obj.transform[backwards ? "unshift" : "push"]({
    [mapTransformKeys[key] || key]: val
  }));
}, mapTransformKeys = {
  x: "translateX",
  y: "translateY"
};
function passDownProp(viewProps, key, val) {
  var shouldMergeObject = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1;
  if (shouldMergeObject) {
    var next = {
      ...viewProps[key],
      ...val
    };
    delete viewProps[key], viewProps[key] = next;
  } else
    viewProps[key] = val;
}
function mergeMediaByImportance(styleState, mediaKey, key, value, importancesUsed, isSizeMedia, importanceBump, debugProp) {
  var importance = getMediaImportanceIfMoreImportant(mediaKey, key, importancesUsed, isSizeMedia);
  if (importanceBump && (importance = (importance || 0) + importanceBump), process.env.NODE_ENV === "development" && debugProp === "verbose" && log(`mergeMediaByImportance ${key} importance existing ${importancesUsed[key]} next ${importance}`), importance === null)
    return !1;
  if (importancesUsed[key] = importance, key in pseudoDescriptors) {
    var descriptor = pseudoDescriptors[key], descriptorKey = descriptor.stateKey || descriptor.name, isDisabled = styleState.componentState[descriptorKey] === !1;
    if (isDisabled)
      return !1;
    for (var subKey in value)
      mergeStyle(styleState, subKey, value[subKey]);
  } else
    mergeStyle(styleState, key, value);
  return !0;
}
function normalizeStyle(style) {
  var out = {};
  for (var key in style) {
    var val = style[key];
    key in stylePropsTransform ? mergeTransform(out, key, val) : out[key] = normalizeValueWithProperty(val, key);
  }
  return isWeb && Array.isArray(out.transform) && (out.transform = transformsToString(out.transform)), fixStyles(out), out;
}
function applyDefaultStyle(pkey, styleState) {
  var defaultValues = animatableDefaults[pkey];
  defaultValues != null && !(pkey in styleState.usedKeys) && (!styleState.style || !(pkey in styleState.style)) && mergeStyle(styleState, pkey, defaultValues);
}
export {
  PROP_SPLIT,
  getSplitStyles,
  getSubStyle,
  useSplitStyles
};
//# sourceMappingURL=getSplitStyles.js.map
