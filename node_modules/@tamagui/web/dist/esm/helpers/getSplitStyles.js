import {
  isClient,
  isServer,
  isWeb,
  useIsomorphicLayoutEffect
} from "@tamagui/constants";
import {
  StyleObjectIdentifier,
  StyleObjectProperty,
  StyleObjectPseudo,
  StyleObjectRules,
  stylePropsText,
  stylePropsTransform,
  tokenCategories,
  validPseudoKeys,
  validStyles
} from "@tamagui/helpers";
import React from "react";
import { getConfig } from "../config";
import { accessibilityDirectMap } from "../constants/accessibilityDirectMap";
import { webViewFlexCompatStyles } from "../constants/constants";
import { isDevTools } from "../constants/isDevTools";
import {
  getMediaImportanceIfMoreImportant,
  mediaState as globalMediaState,
  isMediaKey,
  mediaKeyMatch,
  mediaQueryConfig
} from "../hooks/useMedia";
import { createMediaStyle } from "./createMediaStyle";
import { fixStyles } from "./expandStyles";
import { getGroupPropParts } from "./getGroupPropParts";
import { getStyleAtomic, getStylesAtomic, styleToCSS } from "./getStylesAtomic";
import {
  insertStyleRules,
  insertedTransforms,
  scanAllSheets,
  shouldInsertStyleRules,
  updateRules
} from "./insertStyleRule";
import { isActivePlatform } from "./isActivePlatform";
import { isActiveTheme } from "./isActiveTheme";
import { log } from "./log";
import {
  normalizeValueWithProperty,
  reverseMapClassNameToValue
} from "./normalizeValueWithProperty";
import { getPropMappedFontFamily, propMapper } from "./propMapper";
import { pseudoDescriptors, pseudoPriorities } from "./pseudoDescriptors";
import { skipProps } from "./skipProps";
import { sortString } from "./sortString";
import { transformsToString } from "./transformsToString";
const consoleGroupCollapsed = isWeb ? console.groupCollapsed : console.info;
let conf;
const PROP_SPLIT = "-";
function isValidStyleKey(key, staticConfig) {
  return (staticConfig.validStyles || (staticConfig.isText || staticConfig.isInput ? stylePropsText : validStyles))[key] || staticConfig.accept?.[key];
}
const getSplitStyles = (props, staticConfig, theme, themeName, componentState, styleProps, parentSplitStyles, context, elementType, debug) => {
  conf = conf || getConfig(), isWeb && styleProps.isAnimated && conf.animations.isReactNative && !styleProps.noNormalize && (styleProps.noNormalize = "values");
  const { shorthands } = conf, {
    isHOC,
    isText,
    isInput,
    variants,
    isReactNative,
    inlineProps,
    inlineWhenUnflattened,
    parentStaticConfig,
    acceptsClassName
  } = staticConfig, viewProps = {}, mediaState = styleProps.mediaState || globalMediaState, usedKeys = {}, shouldDoClasses = acceptsClassName && isWeb && !styleProps.noClass, rulesToInsert = {}, classNames = {}, transforms = {};
  let pseudos = null, space = props.space, hasMedia = !1, dynamicThemeAccess, pseudoGroups, mediaGroups, className = props.className || "", mediaStylesSeen = 0;
  const styleState = {
    classNames,
    conf,
    props,
    styleProps,
    componentState,
    staticConfig,
    style: null,
    theme,
    usedKeys,
    viewProps,
    context,
    debug
  };
  process.env.NODE_ENV === "development" && debug && debug !== "profile" && isClient && (consoleGroupCollapsed("getSplitStyles (collapsed)"), log({
    props,
    staticConfig,
    shouldDoClasses,
    styleProps,
    rulesToInsert,
    componentState,
    styleState,
    theme: { ...theme }
  }), console.groupEnd());
  const { asChild } = props, { accept } = staticConfig, { noSkip, disableExpandShorthands, noExpand } = styleProps, { webContainerType } = conf.settings, parentVariants = parentStaticConfig?.variants;
  for (const keyOg in props) {
    let keyInit = keyOg, valInit = props[keyInit];
    if (process.env.NODE_ENV === "test" && keyInit === "jestAnimatedStyle")
      continue;
    if (process.env.NODE_ENV === "development" && debug === "profile" && time`prop-${keyInit}`, accept) {
      const accepted = accept[keyInit];
      if ((accepted === "style" || accepted === "textStyle") && valInit && typeof valInit == "object") {
        viewProps[keyInit] = getSubStyle(styleState, keyInit, valInit, styleProps.noClass);
        continue;
      }
    }
    if (process.env.NODE_ENV === "development" && debug === "verbose" && console.groupEnd(), disableExpandShorthands || keyInit in shorthands && (keyInit = shorthands[keyInit]), keyInit === "className" || keyInit in usedKeys || asChild && webViewFlexCompatStyles[keyInit] === valInit)
      continue;
    if (keyInit in skipProps && !noSkip && !isHOC) {
      if (keyInit === "group") {
        const identifier = `t_group_${valInit}`, containerCSS = [
          "continer",
          void 0,
          identifier,
          void 0,
          [
            `.${identifier} { container-name: ${valInit}; container-type: ${webContainerType || "inline-size"}; }`
          ]
        ];
        addStyleToInsertRules(rulesToInsert, containerCSS);
      }
      continue;
    }
    const valInitType = typeof valInit, isValidStyleKeyInit = isValidStyleKey(keyInit, staticConfig);
    if (staticConfig.isReactNative && keyInit.startsWith("data-")) {
      keyInit = keyInit.replace("data-", ""), viewProps.dataSet ||= {}, viewProps.dataSet[keyInit] = valInit;
      continue;
    }
    if (isValidStyleKeyInit && valInitType === "string" && valInit[0] === "_") {
      const isValidClassName = keyInit in validStyles, isMediaOrPseudo2 = !isValidClassName && // media are flattened for some reason to color-hover keys,
      // we should probably just leave them in place to avoid extra complexity
      keyInit.includes(PROP_SPLIT) && validStyles[keyInit.split(PROP_SPLIT)[0]];
      if (isValidClassName || isMediaOrPseudo2) {
        shouldDoClasses ? (mergeClassName(transforms, classNames, keyInit, valInit, isMediaOrPseudo2), styleState.style && delete styleState.style[keyInit]) : (styleState.style ||= {}, styleState.style[keyInit] = reverseMapClassNameToValue(keyInit, valInit), delete classNames[keyInit]);
        continue;
      }
    }
    if (keyInit === "dataSet") {
      for (const keyInit2 in valInit)
        viewProps[`data-${hyphenate(keyInit2)}`] = valInit[keyInit2];
      continue;
    }
    if (!noExpand) {
      if (keyInit === "disabled" && valInit === !0 && (viewProps["aria-disabled"] = !0, (elementType === "button" || elementType === "form" || elementType === "input" || elementType === "select" || elementType === "textarea") && (viewProps.disabled = !0), !variants?.disabled))
        continue;
      if (keyInit === "testID") {
        viewProps[isReactNative ? keyInit : "data-testid"] = valInit;
        continue;
      }
      if (keyInit === "id" || keyInit === "nativeID") {
        viewProps.id = valInit;
        continue;
      }
      let didUseKeyInit = !1;
      if (isReactNative) {
        if (keyInit in accessibilityDirectMap || keyInit.startsWith("accessibility")) {
          viewProps[keyInit] = valInit;
          continue;
        }
      } else {
        if (didUseKeyInit = !0, keyInit in accessibilityDirectMap) {
          viewProps[accessibilityDirectMap[keyInit]] = valInit;
          continue;
        }
        switch (keyInit) {
          case "accessibilityRole": {
            valInit === "none" ? viewProps.role = "presentation" : viewProps.role = accessibilityRoleToWebRole[valInit] || valInit;
            continue;
          }
          case "accessibilityLabelledBy":
          case "accessibilityFlowTo":
          case "accessibilityControls":
          case "accessibilityDescribedBy": {
            viewProps[`aria-${keyInit.replace("accessibility", "").toLowerCase()}`] = processIDRefList(valInit);
            continue;
          }
          case "accessibilityKeyShortcuts": {
            Array.isArray(valInit) && (viewProps["aria-keyshortcuts"] = valInit.join(" "));
            continue;
          }
          case "accessibilityLiveRegion": {
            viewProps["aria-live"] = valInit === "none" ? "off" : valInit;
            continue;
          }
          case "accessibilityReadOnly": {
            viewProps["aria-readonly"] = valInit, (elementType === "input" || elementType === "select" || elementType === "textarea") && (viewProps.readOnly = !0);
            continue;
          }
          case "accessibilityRequired": {
            viewProps["aria-required"] = valInit, (elementType === "input" || elementType === "select" || elementType === "textarea") && (viewProps.required = valInit);
            continue;
          }
          default:
            didUseKeyInit = !1;
        }
      }
      if (didUseKeyInit)
        continue;
    }
    const isShorthand = keyInit in shorthands;
    let isVariant = !isValidStyleKeyInit && variants && keyInit in variants;
    const isStyleLikeKey = isShorthand || isValidStyleKeyInit || isVariant;
    let isPseudo = keyInit in validPseudoKeys, isMedia = !isStyleLikeKey && !isPseudo && isMediaKey(keyInit), isMediaOrPseudo = !!(isMedia || isPseudo);
    if (isMediaOrPseudo && keyInit.startsWith("$group-")) {
      const parts = keyInit.split("-");
      if (
        // check if its actually a simple group selector to avoid breaking selectors
        parts.length === 2 || parts.length === 3 && pseudoPriorities[parts[parts.length - 1]]
      ) {
        const name = parts[1];
        context?.groups.subscribe && !context?.groups.state[name] && (keyInit = keyInit.replace("$group-", "$group-true-"));
      }
    }
    const isStyleProp = isValidStyleKeyInit || isMediaOrPseudo || isVariant && !noExpand || isShorthand;
    if (isStyleProp && (asChild === "except-style" || asChild === "except-style-web"))
      continue;
    const shouldPassProp = !isStyleProp && isHOC || // is in parent variants
    isHOC && parentVariants && keyInit in parentVariants || inlineProps?.has(keyInit), parentVariant = parentVariants?.[keyInit], isHOCShouldPassThrough = !!(isHOC && (isShorthand || isValidStyleKeyInit || isMediaOrPseudo || parentVariant || keyInit in skipProps)), shouldPassThrough = shouldPassProp || isHOCShouldPassThrough;
    if (process.env.NODE_ENV === "development" && debug === "verbose" && (console.groupEnd(), console.groupEnd(), consoleGroupCollapsed(
      `  \u{1F511} ${keyOg}${keyInit !== keyOg ? ` (shorthand for ${keyInit})` : ""} ${shouldPassThrough ? "(pass)" : ""}`
    ), log({ isVariant, valInit, shouldPassProp }), isClient && log({
      variants,
      variant: variants?.[keyInit],
      isVariant,
      isHOCShouldPassThrough,
      parentStaticConfig
    })), shouldPassThrough && (passDownProp(viewProps, keyInit, valInit, isMediaOrPseudo), !isVariant)) {
      process.env.NODE_ENV === "development" && debug === "verbose" && console.groupEnd();
      continue;
    }
    if (!noSkip && keyInit in skipProps) {
      process.env.NODE_ENV === "development" && debug === "verbose" && console.groupEnd();
      continue;
    }
    (isText || isInput) && valInit && (keyInit === "fontFamily" || keyInit === shorthands.fontFamily) && valInit in conf.fontsParsed && (styleState.fontFamily = valInit);
    const avoidPropMap = isMediaOrPseudo || !isVariant && !isValidStyleKeyInit, expanded = avoidPropMap ? null : propMapper(keyInit, valInit, styleState);
    if (!avoidPropMap) {
      if (!expanded) continue;
      const next = getPropMappedFontFamily(expanded);
      next && (styleState.fontFamily = next);
    }
    if (process.env.NODE_ENV === "development" && debug === "verbose") {
      consoleGroupCollapsed("  \u{1F4A0} expanded", keyInit, valInit);
      try {
        !isServer && isDevTools && (log({
          expanded,
          styleProps,
          componentState,
          isVariant,
          variant: variants?.[keyInit],
          shouldPassProp,
          isHOCShouldPassThrough,
          usedKeys: { ...usedKeys }
        }), globalThis.tamaguiAvoidTracking = !0, log("expanded", expanded, `
usedKeys`, { ...usedKeys }, `
current`, {
          ...styleState.style
        }), globalThis.tamaguiAvoidTracking = !1);
      } catch {
      }
      console.groupEnd();
    }
    let key = keyInit, val = valInit;
    const max = expanded ? expanded.length : 1;
    for (let i = 0; i < max; i++) {
      if (expanded) {
        const [k, v] = expanded[i];
        key = k, val = v;
      }
      if (val == null || key in usedKeys) continue;
      if (isPseudo = key in validPseudoKeys, isMedia = !isPseudo && !isValidStyleKeyInit && isMediaKey(key), isMediaOrPseudo = !!(isMedia || isPseudo), isVariant = variants && key in variants, (inlineProps?.has(key) || process.env.IS_STATIC === "is_static" && inlineWhenUnflattened?.has(key)) && (viewProps[key] = props[key] ?? val), styleProps.noExpand && isPseudo || isHOC && (isMediaOrPseudo || parentStaticConfig?.variants?.[keyInit])) {
        passDownProp(viewProps, key, val, isMediaOrPseudo), process.env.NODE_ENV === "development" && debug === "verbose" && (consoleGroupCollapsed(` - passing down prop ${key}`), log({ val, after: { ...viewProps[key] } }), console.groupEnd());
        continue;
      }
      if (isPseudo) {
        if (!val) continue;
        const pseudoStyleObject = getSubStyle(styleState, key, val, styleProps.noClass), descriptor = pseudoDescriptors[key], isEnter = key === "enterStyle", isExit = key === "exitStyle";
        if (!descriptor)
          continue;
        if ((!shouldDoClasses || process.env.IS_STATIC === "is_static") && (pseudos ||= {}, pseudos[key] ||= {}, process.env.IS_STATIC === "is_static")) {
          Object.assign(pseudos[key], pseudoStyleObject);
          continue;
        }
        if (shouldDoClasses && !isExit) {
          const pseudoStyles = getStyleAtomic(pseudoStyleObject, descriptor);
          process.env.NODE_ENV === "development" && debug === "verbose" && (consoleGroupCollapsed("pseudo (classes)", key), log({ pseudoStyleObject, pseudoStyles }), console.groupEnd());
          for (const psuedoStyle of pseudoStyles) {
            const fullKey = `${psuedoStyle[StyleObjectProperty]}${PROP_SPLIT}${descriptor.name}`;
            fullKey in usedKeys || (addStyleToInsertRules(rulesToInsert, psuedoStyle), mergeClassName(
              transforms,
              classNames,
              fullKey,
              psuedoStyle[StyleObjectIdentifier],
              isMediaOrPseudo,
              !0
            ));
          }
        }
        if (!shouldDoClasses || isExit || isEnter) {
          const descriptorKey = descriptor.stateKey || descriptor.name;
          let isDisabled = componentState[descriptorKey] === !1;
          isExit && (isDisabled = !styleProps.isExiting), isEnter && componentState.unmounted === !1 && (isDisabled = !0), process.env.NODE_ENV === "development" && debug === "verbose" && (consoleGroupCollapsed("pseudo", key, { isDisabled }), log({ pseudoStyleObject, isDisabled, descriptor, componentState }), console.groupEnd());
          const importance = descriptor.priority;
          for (const pkey in pseudoStyleObject) {
            const val2 = pseudoStyleObject[pkey];
            if (isDisabled)
              applyDefaultStyle(pkey, styleState);
            else {
              const curImportance = usedKeys[pkey] || 0, shouldMerge = importance >= curImportance;
              shouldMerge && (pseudos ||= {}, pseudos[key] ||= {}, pseudos[key][pkey] = val2, mergeStyle(styleState, pkey, val2)), process.env.NODE_ENV === "development" && debug === "verbose" && log("    subKey", pkey, shouldMerge, {
                importance,
                curImportance,
                pkey,
                val: val2
              });
            }
          }
          if (!isDisabled)
            for (const key2 in val) {
              const k = shorthands[key2] || key2;
              usedKeys[k] = Math.max(importance, usedKeys[k] || 0);
            }
        }
        continue;
      }
      if (isMedia) {
        if (!val) continue;
        const hasSpace = val.space, mediaKeyShort = key.slice(isMedia == "theme" ? 7 : 1);
        if (hasMedia ||= !0, (hasSpace || !shouldDoClasses || styleProps.willBeAnimated) && (typeof hasMedia != "object" && (hasMedia = {}), hasMedia[mediaKeyShort] = !0), isMedia === "platform" && !isActivePlatform(key))
          continue;
        if (process.env.NODE_ENV === "development" && debug === "verbose" && log(`  \u{1F4FA} ${key}`, {
          key,
          val,
          props,
          shouldDoClasses,
          acceptsClassName,
          componentState,
          mediaState
        }), shouldDoClasses) {
          const mediaStyle = getSubStyle(styleState, key, val, !1);
          if (hasSpace && (delete mediaStyle.space, mediaState[mediaKeyShort])) {
            const importance = getMediaImportanceIfMoreImportant(
              mediaKeyShort,
              "space",
              usedKeys,
              !0
            );
            importance && (space = val.space, usedKeys.space = importance, process.env.NODE_ENV === "development" && debug === "verbose" && log(
              `Found more important space for current media ${mediaKeyShort}: ${val} (importance: ${importance})`
            ));
          }
          const mediaStyles = getStylesAtomic(mediaStyle), priority = mediaStylesSeen;
          mediaStylesSeen += 1;
          for (const style of mediaStyles) {
            const property = style[StyleObjectProperty], isSubStyle = property[0] === "$";
            if (isSubStyle && !isActivePlatform(property))
              continue;
            const out = createMediaStyle(
              style,
              mediaKeyShort,
              mediaQueryConfig,
              isMedia,
              !1,
              priority
            );
            process.env.NODE_ENV === "development" && debug === "verbose" && log("\u{1F4FA} media style:", out);
            const subKey = isSubStyle ? style[2] : "", fullKey = `${style[StyleObjectProperty]}${subKey}${PROP_SPLIT}${mediaKeyShort}${style[StyleObjectPseudo] || ""}`;
            fullKey in usedKeys || (addStyleToInsertRules(rulesToInsert, out), mergeClassName(
              transforms,
              classNames,
              fullKey,
              out[StyleObjectIdentifier],
              !0,
              !0
            ));
          }
        } else {
          let mergeMediaStyle = function(key2, val2) {
            styleState.style ||= {}, mergeMediaByImportance(
              styleState,
              mediaKeyShort,
              key2,
              val2,
              usedKeys,
              mediaState[mediaKeyShort],
              importanceBump,
              debug
            ) && key2 === "fontFamily" && (styleState.fontFamily = mediaStyle.fontFamily);
          };
          const isThemeMedia = isMedia === "theme", isGroupMedia = isMedia === "group";
          if (!isThemeMedia && !(isMedia === "platform") && !isGroupMedia) {
            if (!mediaState[mediaKeyShort]) {
              process.env.NODE_ENV === "development" && debug === "verbose" && log(`  \u{1F4FA} \u274C DISABLED ${mediaKeyShort}`);
              continue;
            }
            process.env.NODE_ENV === "development" && debug === "verbose" && log(`  \u{1F4FA} \u2705 ENABLED ${mediaKeyShort}`);
          }
          const mediaStyle = getSubStyle(styleState, key, val, !0);
          let importanceBump = 0;
          if (isThemeMedia) {
            if (dynamicThemeAccess = !0, !(themeName === mediaKeyShort || themeName.startsWith(mediaKeyShort)))
              continue;
          } else if (isGroupMedia) {
            const groupInfo = getGroupPropParts(mediaKeyShort), groupName = groupInfo.name, groupContext = context?.groups.state[groupName];
            if (!groupContext) {
              process.env.NODE_ENV === "development" && debug && log(`No parent with group prop, skipping styles: ${groupName}`);
              continue;
            }
            const groupPseudoKey = groupInfo.pseudo, groupMediaKey = groupInfo.media, componentGroupState = componentState.group?.[groupName];
            if (groupMediaKey) {
              mediaGroups ||= /* @__PURE__ */ new Set(), mediaGroups.add(groupMediaKey);
              const mediaState2 = componentGroupState?.media;
              let isActive = mediaState2?.[groupMediaKey];
              if (!mediaState2 && groupContext.layout && (isActive = mediaKeyMatch(groupMediaKey, groupContext.layout)), process.env.NODE_ENV === "development" && debug === "verbose" && log(` \u{1F3D8}\uFE0F GROUP media ${groupMediaKey} active? ${isActive}`), !isActive) {
                for (const pkey in mediaStyle)
                  applyDefaultStyle(pkey, styleState);
                continue;
              }
              importanceBump = 2;
            }
            if (groupPseudoKey) {
              pseudoGroups ||= /* @__PURE__ */ new Set(), pseudoGroups.add(groupName);
              const isActive = (componentGroupState || // fallback to context initially
              context.groups.state[groupName]).pseudo?.[groupPseudoKey], priority = pseudoPriorities[groupPseudoKey];
              if (process.env.NODE_ENV === "development" && debug === "verbose" && log(
                ` \u{1F3D8}\uFE0F GROUP pseudo ${groupMediaKey} active? ${isActive}, priority ${priority}`
              ), !isActive) {
                for (const pkey in mediaStyle)
                  applyDefaultStyle(pkey, styleState);
                continue;
              }
              importanceBump = priority;
            }
          }
          for (const subKey in mediaStyle) {
            if (subKey === "space") {
              space = valInit.space;
              continue;
            }
            if (subKey[0] === "$") {
              if (!isActivePlatform(subKey) || !isActiveTheme(subKey, themeName)) continue;
              for (const subSubKey in mediaStyle[subKey])
                mergeMediaStyle(subSubKey, mediaStyle[subKey][subSubKey]);
            } else
              mergeMediaStyle(subKey, mediaStyle[subKey]);
          }
        }
        continue;
      }
      if (
        // is HOC we can just pass through the styles as props
        // this fixes issues where style prop got merged with wrong priority
        !isHOC && isValidStyleKey(key, staticConfig)
      ) {
        mergeStyle(styleState, key, val);
        continue;
      }
      if (!isVariant) {
        if (styleProps.styledContextProps && key in styleProps.styledContextProps)
          continue;
        viewProps[key] = val;
      }
    }
    if (process.env.NODE_ENV === "development" && debug === "verbose") {
      try {
        log(" \u2714\uFE0F expand complete", keyInit), log("style", { ...styleState.style }), log("transforms", { ...transforms }), log("viewProps", { ...viewProps });
      } catch {
      }
      console.groupEnd();
    }
  }
  if (process.env.NODE_ENV === "development" && debug === "profile" && time`split-styles-propsend`, !(styleProps.noNormalize === !1) && (styleState.style && (fixStyles(styleState.style), isWeb && !isReactNative && styleToCSS(styleState.style)), styleState.flatTransforms && (styleState.style ||= {}, Object.entries(styleState.flatTransforms).sort(([a], [b]) => sortString(a, b)).forEach(([key, val]) => {
    mergeTransform(styleState.style, key, val, !0);
  })), parentSplitStyles)) {
    if (shouldDoClasses)
      for (const key in parentSplitStyles.classNames) {
        const val = parentSplitStyles.classNames[key];
        styleState.style && key in styleState.style || key in classNames || (classNames[key] = val);
      }
    if (!shouldDoClasses)
      for (const key in parentSplitStyles.style)
        key in classNames || styleState.style && key in styleState.style || (styleState.style ||= {}, styleState.style[key] = parentSplitStyles.style[key]);
  }
  if (!styleProps.noNormalize && !staticConfig.isReactNative && !staticConfig.isHOC && (!styleProps.isAnimated || conf.animations.supportsCSSVars) && Array.isArray(styleState.style?.transform) && (styleState.style.transform = transformsToString(styleState.style.transform)), styleState.style && shouldDoClasses) {
    let retainedStyles, shouldRetain = !1;
    if (!styleState.style.$$css) {
      const atomic = getStylesAtomic(styleState.style);
      for (const atomicStyle of atomic) {
        const [key, value, identifier] = atomicStyle, isAnimatedAndAnimateOnly = styleProps.isAnimated && styleProps.noClass && props.animateOnly?.includes(key), nonAnimatedAnimateOnly = !isAnimatedAndAnimateOnly && !styleProps.isAnimated && props.animateOnly?.includes(key);
        isAnimatedAndAnimateOnly ? (retainedStyles ||= {}, retainedStyles[key] = styleState.style[key]) : nonAnimatedAnimateOnly ? (retainedStyles ||= {}, retainedStyles[key] = value, shouldRetain = !0) : (addStyleToInsertRules(rulesToInsert, atomicStyle), mergeClassName(transforms, classNames, key, identifier, !1, !0));
      }
      process.env.NODE_ENV === "development" && props.debug === "verbose" && (console.groupEnd(), consoleGroupCollapsed("\u{1F539} getSplitStyles final style object"), console.info(styleState.style), console.info("retainedStyles", retainedStyles), console.groupEnd()), (shouldRetain || process.env.IS_STATIC !== "is_static") && (styleState.style = retainedStyles || {});
    }
    if (transforms)
      for (const namespace in transforms) {
        if (!transforms[namespace]) {
          process.env.NODE_ENV === "development" && log("Error no transform", transforms, namespace);
          continue;
        }
        const [hash, val] = transforms[namespace], identifier = `_transform${hash}`;
        if (isClient && !insertedTransforms[identifier]) {
          const rule = `.${identifier} { transform: ${val}; }`;
          addStyleToInsertRules(rulesToInsert, [
            namespace,
            val,
            identifier,
            void 0,
            [rule]
          ]);
        }
        classNames[namespace] = identifier;
      }
  }
  if (isReactNative)
    viewProps.tabIndex === 0 && (viewProps.accessible ??= !0);
  else if (viewProps.tabIndex == null) {
    const isFocusable = viewProps.focusable ?? viewProps.accessible;
    viewProps.focusable && delete viewProps.focusable;
    const role = viewProps.role;
    isFocusable === !1 && (viewProps.tabIndex = "-1"), // These native elements are focusable by default
    elementType === "a" || elementType === "button" || elementType === "input" || elementType === "select" || elementType === "textarea" ? (isFocusable === !1 || props.accessibilityDisabled === !0) && (viewProps.tabIndex = "-1") : (
      // These roles are made focusable by default
      (role === "button" || role === "checkbox" || role === "link" || role === "radio" || // @ts-expect-error (consistent with RNW)
      role === "textbox" || role === "switch") && isFocusable !== !1 && (viewProps.tabIndex = "0")
    ), isFocusable && (viewProps.tabIndex = "0", delete viewProps.focusable);
  }
  const styleProp = props.style;
  if (styleProp)
    if (isHOC)
      viewProps.style = normalizeStyle(styleProp);
    else {
      const isArray = Array.isArray(styleProp), len = isArray ? styleProp.length : 1;
      for (let i = 0; i < len; i++) {
        const style = isArray ? styleProp[i] : styleProp;
        style && (style.$$css ? Object.assign(styleState.classNames, style) : (styleState.style ||= {}, Object.assign(styleState.style, normalizeStyle(style))));
      }
    }
  process.env.NODE_ENV === "development" && debug === "profile" && time`split-styles-pre-result`;
  const result = {
    space,
    hasMedia,
    fontFamily: styleState.fontFamily,
    viewProps,
    style: styleState.style,
    pseudos,
    classNames,
    rulesToInsert,
    dynamicThemeAccess,
    pseudoGroups,
    mediaGroups
  };
  if (!(asChild === "except-style" || asChild === "except-style-web")) {
    const style = styleState.style;
    {
      let fontFamily = isText || isInput ? styleState.fontFamily || staticConfig.defaultProps?.fontFamily : null;
      fontFamily && fontFamily[0] === "$" && (fontFamily = fontFamily.slice(1));
      const fontFamilyClassName = fontFamily ? `font_${fontFamily}` : "", groupClassName = props.group ? `t_group_${props.group}` : "", componentNameFinal = props.componentName || staticConfig.componentName, componentClassName = props.asChild || !componentNameFinal ? "" : `is_${componentNameFinal}`;
      let classList = [];
      componentClassName && classList.push(componentClassName), fontFamilyClassName && classList.push(fontFamilyClassName), classNames && classList.push(Object.values(classNames).join(" ")), groupClassName && classList.push(groupClassName), props.className && classList.push(props.className);
      const finalClassName = classList.join(" ");
      if (styleProps.noMergeStyle)
        finalClassName && (viewProps.className = finalClassName);
      else if (styleProps.isAnimated && !conf.animations.supportsCSSVars && isReactNative)
        style && (viewProps.style = style);
      else if (isReactNative) {
        const cnStyles = { $$css: !0 };
        for (const name of finalClassName.split(" "))
          cnStyles[name] = name;
        viewProps.style = [...Array.isArray(style) ? style : [style], cnStyles];
      } else
        finalClassName && (viewProps.className = finalClassName), style && (viewProps.style = style);
    }
  }
  if (process.env.NODE_ENV === "development" && debug === "verbose" && isDevTools) {
    consoleGroupCollapsed("\u{1F539} getSplitStyles ===>");
    try {
      const logs = {
        ...result,
        className,
        componentState,
        transforms,
        viewProps,
        rulesToInsert,
        parentSplitStyles
      };
      for (const key in logs)
        log(key, logs[key]);
    } catch {
    }
    console.groupEnd();
  }
  return process.env.NODE_ENV === "development" && debug === "profile" && time`split-styles-done`, result;
};
function mergeClassName(transforms, classNames, key, val, isMediaOrPseudo = !1, isInsertingNow = !1) {
  if (val)
    if (!isInsertingNow && val[0] === "_" && val.startsWith("_transform-")) {
      const ns = isMediaOrPseudo ? key : "transform";
      let transform = insertedTransforms[val];
      isClient && !transform && (scanAllSheets(), transform = insertedTransforms[val], !transform && isWeb && val[0] !== "_" && (transform = val)), transforms[ns] ||= ["", ""], transforms[ns][0] += val.replace("_transform", ""), transform && (transforms[ns][1] += transform);
    } else
      classNames[key] = val;
}
function mergeStyle(styleState, key, val, disableNormalize = !1) {
  const { classNames, viewProps, usedKeys, styleProps, staticConfig } = styleState;
  if (isWeb && val?.[0] === "_")
    classNames[key] = val, usedKeys[key] ||= 1;
  else if (key in stylePropsTransform)
    styleState.flatTransforms ||= {}, styleState.flatTransforms[key] = val;
  else {
    const out = isWeb && !disableNormalize && !styleProps.noNormalize ? normalizeValueWithProperty(val, key) : val;
    // accept is for props not styles
    staticConfig.accept && key in staticConfig.accept ? viewProps[key] = out : (styleState.style ||= {}, styleState.style[key] = out);
  }
}
const getSubStyle = (styleState, subKey, styleIn, avoidMergeTransform) => {
  const { staticConfig, conf: conf2, styleProps } = styleState, styleOut = {};
  for (let key in styleIn) {
    const val = styleIn[key];
    key = conf2.shorthands[key] || key;
    const expanded = propMapper(key, val, styleState);
    if (!(!expanded || !staticConfig.isHOC && key in skipProps && !styleProps.noSkip))
      for (let [skey, sval] of expanded)
        skey in validPseudoKeys && (sval = getSubStyle(styleState, skey, sval, avoidMergeTransform)), !avoidMergeTransform && skey in stylePropsTransform ? mergeTransform(styleOut, skey, sval) : styleOut[skey] = styleProps.noNormalize ? sval : normalizeValueWithProperty(sval, key);
  }
  return styleProps.noNormalize || fixStyles(styleOut), styleOut;
}, useInsertEffectCompat = isWeb ? React.useInsertionEffect || useIsomorphicLayoutEffect : () => {
}, useSplitStyles = (a, b, c, d, e, f, g, h, i, j) => {
  conf = conf || getConfig();
  const res = getSplitStyles(a, b, c, d, e, f, g, h, i, j);
  return process.env.TAMAGUI_REACT_19 || useInsertEffectCompat(() => {
    insertStyleRules(res.rulesToInsert);
  }, [res.rulesToInsert]), res;
};
function addStyleToInsertRules(rulesToInsert, styleObject) {
  {
    const identifier = styleObject[StyleObjectIdentifier];
    process.env.TAMAGUI_REACT_19 || shouldInsertStyleRules(identifier) && updateRules(identifier, styleObject[StyleObjectRules]), rulesToInsert[identifier] = styleObject;
  }
}
function processIDRefList(idRefList) {
  return Array.isArray(idRefList) ? idRefList.join(" ") : idRefList;
}
const defaultColor = process.env.TAMAGUI_DEFAULT_COLOR || "rgba(0,0,0,0)", animatableDefaults = {
  ...Object.fromEntries(
    Object.entries(tokenCategories.color).map(([k, v]) => [k, defaultColor])
  ),
  opacity: 1,
  scale: 1,
  rotate: "0deg",
  rotateY: "0deg",
  rotateX: "0deg",
  x: 0,
  y: 0,
  borderRadius: 0
}, lowercaseHyphenate = (match) => `-${match.toLowerCase()}`, hyphenate = (str) => str.replace(/[A-Z]/g, lowercaseHyphenate), mergeTransform = (obj, key, val, backwards = !1) => {
  typeof obj.transform != "string" && (obj.transform ||= [], obj.transform[backwards ? "unshift" : "push"]({
    [mapTransformKeys[key] || key]: val
  }));
}, mapTransformKeys = {
  x: "translateX",
  y: "translateY"
}, accessibilityRoleToWebRole = {
  adjustable: "slider",
  header: "heading",
  image: "img",
  link: "link",
  none: "presentation",
  summary: "region"
};
function passDownProp(viewProps, key, val, shouldMergeObject = !1) {
  if (shouldMergeObject) {
    const next = {
      ...viewProps[key],
      ...val
    };
    delete viewProps[key], viewProps[key] = next;
  } else
    viewProps[key] = val;
}
function mergeMediaByImportance(styleState, mediaKey, key, value, importancesUsed, isSizeMedia, importanceBump, debugProp) {
  let importance = getMediaImportanceIfMoreImportant(
    mediaKey,
    key,
    importancesUsed,
    isSizeMedia
  );
  if (importanceBump && (importance = (importance || 0) + importanceBump), process.env.NODE_ENV === "development" && debugProp === "verbose" && log(
    `mergeMediaByImportance ${key} importance existing ${importancesUsed[key]} next ${importance}`
  ), importance === null)
    return !1;
  if (importancesUsed[key] = importance, key in pseudoDescriptors) {
    const descriptor = pseudoDescriptors[key], descriptorKey = descriptor.stateKey || descriptor.name;
    if (styleState.componentState[descriptorKey] === !1)
      return !1;
    for (const subKey in value)
      mergeStyle(styleState, subKey, value[subKey]);
  } else
    mergeStyle(styleState, key, value);
  return !0;
}
function normalizeStyle(style) {
  const out = {};
  for (const key in style) {
    const val = style[key];
    key in stylePropsTransform ? mergeTransform(out, key, val) : out[key] = normalizeValueWithProperty(val, key);
  }
  return isWeb && Array.isArray(out.transform) && (out.transform = transformsToString(out.transform)), fixStyles(out), out;
}
function applyDefaultStyle(pkey, styleState) {
  const defaultValues = animatableDefaults[pkey];
  defaultValues != null && !(pkey in styleState.usedKeys) && (!styleState.style || !(pkey in styleState.style)) && mergeStyle(styleState, pkey, defaultValues);
}
export {
  PROP_SPLIT,
  getSplitStyles,
  getSubStyle,
  useSplitStyles
};
//# sourceMappingURL=getSplitStyles.js.map
