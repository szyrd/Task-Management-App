import React from "react";
import { isClient, isIos, isServer, isWeb } from "@tamagui/constants";
import { getConfig, getSetting } from "../config";
import { getVariable } from "../createVariable";
import { ThemeManager, getHasThemeUpdatingProps } from "../helpers/ThemeManager";
import { ThemeManagerIDContext } from "../helpers/ThemeManagerContext";
import { isEqualShallow } from "../helpers/createShallowSetState";
import { shouldDeoptDueToParentScheme } from "./shouldDeoptDueToParentScheme";
var emptyProps = {
  name: null
}, cached;
function getDefaultThemeProxied() {
  if (cached) return cached;
  var config = getConfig(), name = config.themes.light ? "light" : Object.keys(config.themes)[0], defaultTheme = config.themes[name];
  return cached = getThemeProxied({
    theme: defaultTheme,
    name
  }), cached;
}
var useTheme = function() {
  var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : emptyProps, [_, theme] = useThemeWithState(props), res = theme || getDefaultThemeProxied();
  return res;
}, useThemeWithState = function(props) {
  var keys = React.useRef([]), changedThemeState = useChangeThemeEffect(props, !1, keys.current, isServer ? void 0 : function() {
    var _props_shouldUpdate, _props_shouldUpdate1, next = (_props_shouldUpdate1 = (_props_shouldUpdate = props.shouldUpdate) === null || _props_shouldUpdate === void 0 ? void 0 : _props_shouldUpdate.call(props)) !== null && _props_shouldUpdate1 !== void 0 ? _props_shouldUpdate1 : keys.current.length > 0 ? !0 : void 0;
    if (process.env.NODE_ENV === "development" && typeof props.debug == "string" && props.debug !== "profile") {
      var _props_shouldUpdate2;
      console.info(`  \u{1F3A8} useTheme() shouldUpdate? tracking keys ${keys.current.length} ${(_props_shouldUpdate2 = props.shouldUpdate) === null || _props_shouldUpdate2 === void 0 ? void 0 : _props_shouldUpdate2.call(props)}`, next);
    }
    return next;
  }), { themeManager, state } = changedThemeState;
  process.env.NODE_ENV === "development" && (state?.theme || process.env.TAMAGUI_DISABLE_NO_THEME_WARNING !== "1" && console.error(`[tamagui] No theme found, this could be due to an invalid theme name (given theme props ${JSON.stringify(props)}).

If this is intended and you are using Tamagui without any themes, you can disable this warning by setting the environment variable TAMAGUI_DISABLE_NO_THEME_WARNING=1`));
  var themeProxied = React.useMemo(function() {
    return keys.current = [], !themeManager || !state?.theme ? {} : getThemeProxied(state, props.deopt, themeManager, keys.current, props.debug);
  }, [
    state?.theme,
    themeManager,
    props.deopt,
    props.debug
  ]);
  return process.env.NODE_ENV === "development" && props.debug === "verbose" && (console.groupCollapsed(`  \u{1F539} [${themeManager?.id}] useTheme =>`, state?.name), console.info("returning state", changedThemeState.state, changedThemeState.isNewTheme, "from props", props), console.groupEnd()), [
    changedThemeState,
    themeProxied
  ];
};
function getThemeProxied(param) {
  var { theme, name, scheme } = param, deopt = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, themeManager = arguments.length > 2 ? arguments[2] : void 0, keys = arguments.length > 3 ? arguments[3] : void 0, debug = arguments.length > 4 ? arguments[4] : void 0;
  if (!theme) return {};
  var config = getConfig();
  function track(key) {
    keys && !keys.includes(key) && (keys.length || setTimeout(function() {
      themeManager?.selfUpdate();
    }), keys.push(key), process.env.NODE_ENV === "development" && debug && console.info(` \u{1F3A8} useTheme() tracking new key: ${key}`));
  }
  return new Proxy(theme, {
    has(_, key) {
      if (Reflect.has(theme, key))
        return !0;
      if (typeof key == "string")
        return key[0] === "$" && (key = key.slice(1)), themeManager?.allKeys.has(key);
    },
    get(_, key) {
      if (
        // dont ask me, idk why but on hermes you can see that useTheme()[undefined] passes in STRING undefined to proxy
        // if someone is crazy enough to use "undefined" as a theme key then this not working is on them
        key !== "undefined" && typeof key == "string"
      ) {
        var keyString = key[0] === "$" ? key.slice(1) : key, val = theme[keyString];
        if (val && typeof val == "object")
          return new Proxy(val, {
            // when they touch the actual value we only track it
            // if its a variable (web), its ignored!
            get(_2, subkey) {
              if (subkey === "val")
                globalThis.tamaguiAvoidTracking || (process.env.NODE_ENV === "development" && debug === "verbose" && console.info(" \u{1F3A8} useTheme() tracking new key because of .val access", new Error().stack), track(keyString));
              else if (subkey === "get")
                return function(platform) {
                  var outVal = getVariable(val);
                  if (platform !== "web" && isIos && !deopt && getSetting("fastSchemeChange") && !shouldDeoptDueToParentScheme(themeManager) && scheme) {
                    var _config_themes_name, _config_themes_oppositeName, oppositeScheme = scheme === "dark" ? "light" : "dark", oppositeName = name.replace(scheme, oppositeScheme), color = getVariable((_config_themes_name = config.themes[name]) === null || _config_themes_name === void 0 ? void 0 : _config_themes_name[keyString]), oppositeColor = getVariable((_config_themes_oppositeName = config.themes[oppositeName]) === null || _config_themes_oppositeName === void 0 ? void 0 : _config_themes_oppositeName[keyString]), dynamicVal = {
                      dynamic: {
                        [scheme]: color,
                        [oppositeScheme]: oppositeColor
                      }
                    };
                    return dynamicVal;
                  }
                  return process.env.NODE_ENV === "development" && debug && console.info(` \u{1F3A8} useTheme() tracking new key because of: 
                        not web: ${platform !== "web"}
                        isIOS: ${isIos}
                        deopt: ${deopt}
                        fastScheme: ${getSetting("fastSchemeChange")}
                        inversed: ${getIsInversed(themeManager)}
                      `), track(keyString), outVal;
                };
              return Reflect.get(val, subkey);
            }
          });
        if (process.env.NODE_ENV === "development" && process.env.TAMAGUI_FEAT_THROW_ON_MISSING_THEME_VALUE === "1")
          throw new Error(`[tamagui] No theme key "${key}" found in theme ${name}. 
  Keys in theme: ${Object.keys(theme).join(", ")}`);
      }
      return Reflect.get(_, key);
    }
  });
}
function getIsInversed(manager) {
  for (var isInversed = !1, cur = manager; cur; ) {
    if (!cur.parentManager) return isInversed;
    cur.parentManager.state.scheme !== cur.state.scheme && (isInversed = !isInversed), cur = cur.parentManager;
  }
  return !1;
}
var activeThemeManagers = /* @__PURE__ */ new Set(), _uidToManager = /* @__PURE__ */ new WeakMap(), _idToUID = {}, getId = function(id) {
  return _idToUID[id];
}, getThemeManager = function(id) {
  return _uidToManager.get(getId(id));
}, registerThemeManager = function(t) {
  if (!_idToUID[t.id]) {
    var id = _idToUID[t.id] = {};
    _uidToManager.set(id, t);
  }
}, ogLog = console.error, preventWarnSetState = process.env.NODE_ENV === "production" ? ogLog : (
  // temporary fix for logs, they are harmless in that i've tried to rewrite this
  // a few times using the "right" ways, but they are always slower. maybe skill issue
  function(a) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++)
      args[_key - 1] = arguments[_key];
    if (!(typeof a == "string" && a.includes("Cannot update a component")))
      return ogLog(a, ...args);
  }
), useChangeThemeEffect = function(props) {
  var isRoot = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, keys = arguments.length > 2 ? arguments[2] : void 0, shouldUpdate = arguments.length > 3 ? arguments[3] : void 0, { disable } = props, parentManagerId = React.useContext(ThemeManagerIDContext), parentManager = getThemeManager(parentManagerId);
  if (!isRoot && !parentManager || disable)
    return {
      isNewTheme: !1,
      state: parentManager?.state,
      themeManager: parentManager
    };
  var [themeState, setThemeState] = React.useState(createState), { state, mounted, isNewTheme, themeManager, prevState } = themeState, isInversingOnMount = !!(!themeState.mounted && props.inverse);
  function getShouldUpdateTheme() {
    var manager = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : themeManager, nextState = arguments.length > 1 ? arguments[1] : void 0, prevState2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : state, forceShouldChange = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1, forceUpdate = shouldUpdate?.();
    if (!(!manager || !forceShouldChange && forceUpdate === !1)) {
      var next2 = nextState || manager.getState(props, parentManager);
      if (forceShouldChange)
        return next2;
      if (next2 && !(forceUpdate !== !0 && !manager.getStateShouldChange(next2, prevState2)))
        return next2;
    }
  }
  if (themeManager && getShouldUpdateTheme(themeManager)) {
    var _next_state, _themeState_state, next = createState(themeState);
    ((_next_state = next.state) === null || _next_state === void 0 ? void 0 : _next_state.name) !== ((_themeState_state = themeState.state) === null || _themeState_state === void 0 ? void 0 : _themeState_state.name) && (setThemeState(next), console.error = preventWarnSetState, themeManager.notify(), console.error = ogLog);
  }
  if (isServer || (React.useLayoutEffect(function() {
    themeManager && state && prevState && state !== prevState && themeManager.notify();
  }, [
    state
  ]), React.useEffect(function() {
    if (themeManager) {
      if (props.inverse && !mounted) {
        setThemeState(function(prev) {
          return createState({
            ...prev,
            mounted: !0
          });
        });
        return;
      }
      (isNewTheme || getShouldUpdateTheme(themeManager)) && (activeThemeManagers.add(themeManager), setThemeState(createState));
      var selfListenerDispose = themeManager.onChangeTheme(function(_a, _b, forced) {
        forced && setThemeState(function(prev) {
          var next2 = createState(prev, forced !== "self");
          return next2;
        });
      }, !0), disposeChangeListener = parentManager?.onChangeTheme(function(name, manager, forced) {
        var force = forced || shouldUpdate?.() || props.deopt || props["disable-child-theme"], shouldTryUpdate = force ?? !!(keys?.length || isNewTheme);
        process.env.NODE_ENV === "development" && props.debug === "verbose" && console.info(" \u{1F538} onChange", {
          id: themeManager.id,
          force,
          shouldTryUpdate,
          props,
          name,
          keys
        }), shouldTryUpdate && setThemeState(function(prev) {
          return createState(prev, force);
        });
      }, themeManager.id);
      return function() {
        selfListenerDispose(), disposeChangeListener?.(), isNewTheme && activeThemeManagers.delete(themeManager);
      };
    }
  }, [
    themeManager,
    parentManager,
    isNewTheme,
    props.componentName,
    props.inverse,
    props.name,
    props.reset,
    mounted
  ]), process.env.NODE_ENV === "development" && props.debug !== "profile" && React.useEffect(function() {
    var _globalThis, _TamaguiThemeManagers, _;
    return (_ = (_globalThis = globalThis)[_TamaguiThemeManagers = "TamaguiThemeManagers"]) !== null && _ !== void 0 || (_globalThis[_TamaguiThemeManagers] = /* @__PURE__ */ new Set()), globalThis.TamaguiThemeManagers.add(themeManager), function() {
      globalThis.TamaguiThemeManagers.delete(themeManager);
    };
  }, [
    themeManager
  ])), isWeb && isInversingOnMount)
    return {
      isNewTheme: !1,
      inversed: !1,
      themeManager: parentManager,
      state: {
        name: "",
        ...parentManager?.state,
        className: ""
      }
    };
  return {
    state,
    isNewTheme,
    inversed: !!props.inverse,
    themeManager
  };
  function createState(prev) {
    var force = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
    if (prev && shouldUpdate?.() === !1 && !force)
      return prev;
    var themeManager2 = parentManager, state2, hasThemeUpdatingProps = getHasThemeUpdatingProps(props);
    if (hasThemeUpdatingProps) {
      var getNewThemeManager = function() {
        return new ThemeManager(props, isRoot ? "root" : parentManager);
      };
      if (prev?.themeManager) {
        themeManager2 = prev.themeManager;
        var forceChange = force || !!keys?.length, next2 = themeManager2.getState(props, parentManager), nextState = getShouldUpdateTheme(themeManager2, next2, prev.state, forceChange);
        nextState ? (state2 = nextState, !prev.isNewTheme && !isRoot ? themeManager2 = getNewThemeManager() : themeManager2.updateState(nextState)) : prev.isNewTheme && parentManager && !next2 && (themeManager2 = parentManager);
      } else
        themeManager2 = getNewThemeManager(), state2 = {
          ...themeManager2.state
        };
    }
    var isNewTheme2 = !!(themeManager2 !== parentManager || props.inverse);
    isNewTheme2 && registerThemeManager(themeManager2);
    var isWebSSR = isWeb ? !getSetting("disableSSR") : !1, mounted2 = isWebSSR ? isRoot || prev?.mounted : !0;
    state2 || (isNewTheme2 ? state2 = themeManager2.state : (state2 = parentManager.state, themeManager2 = parentManager));
    var response = {
      themeManager: themeManager2,
      isNewTheme: isNewTheme2,
      mounted: mounted2,
      inversed: props.inverse
    }, shouldReturnPrev = prev && !force && // isEqualShallow uses the second arg as the keys so this should compare without state first...
    isEqualShallow(prev, response) && // ... and then compare just the state, because we make a new state obj but is likely the same
    isEqualShallow(prev.state, state2);
    if (prev && shouldReturnPrev)
      return prev;
    if (response.state = state2, response.prevState = prev?.state, process.env.NODE_ENV === "development" && props.debug && isClient) {
      console.groupCollapsed(`\u{1F537} [${themeManager2.id}] useChangeThemeEffect createState`);
      var parentState = {
        ...parentManager?.state
      }, parentId = parentManager?.id, themeManagerState = {
        ...themeManager2.state
      };
      console.info({
        props,
        parentState,
        parentId,
        themeManager: themeManager2,
        prev,
        response,
        themeManagerState
      }), console.groupEnd();
    }
    return response;
  }
};
export {
  activeThemeManagers,
  getThemeManager,
  getThemeProxied,
  useChangeThemeEffect,
  useTheme,
  useThemeWithState
};
//# sourceMappingURL=useTheme.js.map
