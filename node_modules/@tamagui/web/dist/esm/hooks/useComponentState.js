import { isServer, isWeb } from "@tamagui/constants";
import { useDidFinishSSR } from "@tamagui/use-did-finish-ssr";
import { useRef, useState } from "react";
import {
  defaultComponentState,
  defaultComponentStateMounted,
  defaultComponentStateShouldEnter
} from "../defaultComponentState";
import { createShallowSetState } from "../helpers/createShallowSetState";
import { isObj } from "../helpers/isObj";
import { log } from "../helpers/log";
const useComponentState = (props, { animationDriver, groups }, staticConfig, config) => {
  const isHydrated = useDidFinishSSR(), useAnimations = animationDriver?.useAnimations, stateRef = useRef(
    void 0
  );
  stateRef.current || (stateRef.current = {});
  const hasAnimationProp = !!("animation" in props || props.style && hasAnimatedStyleValue(props.style)), supportsCSSVars = animationDriver?.supportsCSSVars, curStateRef = stateRef.current, willBeAnimatedClient = !!(!!(hasAnimationProp && !staticConfig.isHOC && useAnimations) || curStateRef.hasAnimated), willBeAnimated = !isServer && willBeAnimatedClient;
  willBeAnimated && !curStateRef.hasAnimated && (curStateRef.hasAnimated = !0);
  const { disableClassName } = props, presence = willBeAnimated && props.animatePresence !== !1 && animationDriver?.usePresence?.() || null, presenceState = presence?.[2], isExiting = presenceState?.isPresent === !1, isEntering = presenceState?.isPresent === !0 && presenceState.initial !== !1, hasEnterStyle = !!props.enterStyle, hasAnimationThatNeedsHydrate = hasAnimationProp && !isHydrated && (animationDriver?.isReactNative || !supportsCSSVars), hasEnterState = hasEnterStyle || isEntering, initialState = hasEnterState || hasAnimationThatNeedsHydrate || // disableClassName doesnt work server side, only client, so needs hydrate
  // this is just for a better ux, supports css variables for light/dark, media queries, etc
  disableClassName ? (
    // on the very first render we switch all spring animation drivers to css rendering
    // this is because we need to use css variables, which they don't support to do proper SSR
    // without flickers of the wrong colors.
    // but once we do that initial hydration and we are in client side rendering mode,
    // we can avoid the extra re-render on mount
    hasEnterState ? defaultComponentStateShouldEnter : defaultComponentState
  ) : defaultComponentStateMounted, disabled = isDisabled(props);
  disabled != null && (initialState.disabled = disabled);
  const states = useState(initialState), state = props.forceStyle ? { ...states[0], [props.forceStyle]: !0 } : states[0], setState = states[1];
  let isAnimated = willBeAnimated;
  isWeb && hasAnimationThatNeedsHydrate && !staticConfig.isHOC && !isHydrated && (isAnimated = !1, curStateRef.willHydrate = !0), disabled !== state.disabled && (state.disabled = disabled, disabled && Object.assign(state, defaultComponentStateMounted), setState({ ...state }));
  let setStateShallow = createShallowSetState(setState, disabled, !1, props.debug);
  if (presenceState && isAnimated && isHydrated && staticConfig.variants) {
    process.env.NODE_ENV === "development" && props.debug === "verbose" && console.warn(`has presenceState ${JSON.stringify(presenceState)}`);
    const { enterVariant, exitVariant, enterExitVariant, custom } = presenceState;
    isObj(custom) && Object.assign(props, custom);
    const exv = exitVariant ?? enterExitVariant, env = enterVariant ?? enterExitVariant;
    state.unmounted && env && staticConfig.variants[env] ? (process.env.NODE_ENV === "development" && props.debug === "verbose" && console.warn(`Animating presence ENTER "${env}"`), props[env] = !0) : isExiting && exv && (process.env.NODE_ENV === "development" && props.debug === "verbose" && console.warn(`Animating presence EXIT "${exv}"`), props[exv] = exitVariant !== enterExitVariant);
  }
  let noClass = !isWeb || !!props.forceStyle;
  if (isWeb && (!isServer || isHydrated)) {
    const isAnimatedAndHydrated = isAnimated && !supportsCSSVars, isClassNameDisabled = !staticConfig.acceptsClassName && (config.disableSSR || !state.unmounted), isDisabledManually = disableClassName && !state.unmounted;
    (isAnimatedAndHydrated || isDisabledManually || isClassNameDisabled) && (noClass = !0, process.env.NODE_ENV === "development" && props.debug && log("avoiding className", {
      isAnimatedAndHydrated,
      isDisabledManually,
      isClassNameDisabled
    }));
  }
  const groupName = props.group;
  if (groupName && !curStateRef.group) {
    const listeners = /* @__PURE__ */ new Set();
    curStateRef.group = {
      listeners,
      emit(name, state2) {
        listeners.forEach((l) => l(name, state2));
      },
      subscribe(cb) {
        return listeners.add(cb), () => {
          listeners.delete(cb);
        };
      }
    };
  }
  if (groupName) {
    const groupContextState = groups.state, og = setStateShallow;
    setStateShallow = (state2) => {
      og(state2), curStateRef.group.emit(groupName, {
        pseudo: state2
      });
      const next = {
        ...groupContextState[groupName],
        ...state2
      };
      groupContextState[groupName] = next;
    };
  }
  return {
    curStateRef,
    disabled,
    groupName,
    hasAnimationProp,
    hasEnterStyle,
    isAnimated,
    isExiting,
    isHydrated,
    presence,
    presenceState,
    setState,
    setStateShallow,
    noClass,
    state,
    stateRef,
    supportsCSSVars,
    willBeAnimated,
    willBeAnimatedClient
  };
};
function hasAnimatedStyleValue(style) {
  return Object.keys(style).some((k) => {
    const val = style[k];
    return val && typeof val == "object" && "_animation" in val;
  });
}
const isDisabled = (props) => props.disabled || props.accessibilityState?.disabled || props["aria-disabled"] || props.accessibilityDisabled || !1;
export {
  useComponentState
};
//# sourceMappingURL=useComponentState.js.map
