import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import { Adapt, AdaptParent, AdaptPortalContents, useAdaptIsActive } from "@tamagui/adapt";
import { AnimatePresence } from "@tamagui/animate-presence";
import { hideOthers } from "@tamagui/aria-hidden";
import { useComposedRefs } from "@tamagui/compose-refs";
import { isWeb } from "@tamagui/constants";
import { Theme, View, spacedChildren, styled, useThemeName } from "@tamagui/core";
import { createContext, createContextScope } from "@tamagui/create-context";
import { Dismissable } from "@tamagui/dismissable";
import { FocusScope } from "@tamagui/focus-scope";
import { composeEventHandlers, withStaticProperties } from "@tamagui/helpers";
import { Portal } from "@tamagui/portal";
import { RemoveScroll } from "@tamagui/remove-scroll";
import { Overlay, Sheet, SheetController } from "@tamagui/sheet";
import { ButtonNestingContext, ThemeableStack, YStack } from "@tamagui/stacks";
import { H2, Paragraph } from "@tamagui/text";
import { useControllableState } from "@tamagui/use-controllable-state";
import * as React from "react";
var DIALOG_NAME = "Dialog", [createDialogContext, createDialogScope] = createContextScope(DIALOG_NAME), [DialogProvider, useDialogContext] = createDialogContext(DIALOG_NAME), TRIGGER_NAME = "DialogTrigger", DialogTriggerFrame = styled(View, {
  name: TRIGGER_NAME
}), DialogTrigger = DialogTriggerFrame.styleable(function(props, forwardedRef) {
  var { __scopeDialog, ...triggerProps } = props, isInsideButton = React.useContext(ButtonNestingContext), context = useDialogContext(TRIGGER_NAME, __scopeDialog), composedTriggerRef = useComposedRefs(forwardedRef, context.triggerRef);
  return /* @__PURE__ */ _jsx(ButtonNestingContext.Provider, {
    value: !0,
    children: /* @__PURE__ */ _jsx(DialogTriggerFrame, {
      tag: isInsideButton ? "span" : "button",
      "aria-haspopup": "dialog",
      "aria-expanded": context.open,
      "aria-controls": context.contentId,
      "data-state": getState(context.open),
      ...triggerProps,
      ref: composedTriggerRef,
      onPress: composeEventHandlers(props.onPress, context.onOpenToggle)
    })
  });
}), PORTAL_NAME = "DialogPortal", [PortalProvider, usePortalContext] = createDialogContext(PORTAL_NAME, {
  forceMount: void 0
}), DialogPortalFrame = styled(YStack, {
  pointerEvents: "none",
  variants: {
    unstyled: {
      false: {
        alignItems: "center",
        justifyContent: "center",
        fullscreen: !0,
        zIndex: 1e5,
        ...isWeb && {
          maxHeight: "100vh",
          position: "fixed"
        }
      }
    }
  },
  defaultVariants: {
    unstyled: process.env.TAMAGUI_HEADLESS === "1"
  }
}), DialogPortalItem = function(props) {
  var { __scopeDialog, children, space, spaceDirection, separator } = props, themeName = useThemeName(), context = useDialogContext(PORTAL_NAME, props.__scopeDialog), childrenSpaced = children;
  return (space || separator) && (childrenSpaced = spacedChildren({
    children,
    separator,
    space,
    direction: spaceDirection
  })), /* @__PURE__ */ _jsx(AdaptPortalContents, {
    children: /* @__PURE__ */ _jsx(DialogProvider, {
      scope: __scopeDialog,
      ...context,
      children: /* @__PURE__ */ _jsx(Theme, {
        name: themeName,
        children: childrenSpaced
      })
    })
  });
}, DialogPortal = function(props) {
  var { __scopeDialog, forceMount, children, ...frameProps } = props, context = useDialogContext(PORTAL_NAME, __scopeDialog), isShowing = forceMount || context.open, [isFullyHidden, setIsFullyHidden] = React.useState(!isShowing), isAdapted = useAdaptIsActive();
  isShowing && isFullyHidden && setIsFullyHidden(!1);
  var handleExitComplete = React.useCallback(function() {
    setIsFullyHidden(!0);
  }, []);
  if (context.modal) {
    var contents = /* @__PURE__ */ _jsx(AnimatePresence, {
      onExitComplete: handleExitComplete,
      children: isShowing || isAdapted ? children : null
    });
    if (isFullyHidden && !isAdapted)
      return null;
    var framedContents = /* @__PURE__ */ _jsx(PortalProvider, {
      scope: __scopeDialog,
      forceMount,
      children: /* @__PURE__ */ _jsx(DialogPortalFrame, {
        pointerEvents: isShowing ? "auto" : "none",
        ...frameProps,
        children: contents
      })
    });
    if (isWeb) {
      var _props_zIndex;
      return /* @__PURE__ */ _jsx(Portal, {
        zIndex: (_props_zIndex = props.zIndex) !== null && _props_zIndex !== void 0 ? _props_zIndex : 1e5,
        children: /* @__PURE__ */ _jsx(PassthroughTheme, {
          children: framedContents
        })
      });
    }
    return framedContents;
  }
  return children;
}, PassthroughTheme = function(param) {
  var { children } = param, themeName = useThemeName();
  return /* @__PURE__ */ _jsx(Theme, {
    name: themeName,
    forceClassName: !0,
    children
  });
}, OVERLAY_NAME = "DialogOverlay", DialogOverlayFrame = styled(Overlay, {
  name: OVERLAY_NAME
}), DialogOverlay = DialogOverlayFrame.extractable(/* @__PURE__ */ React.forwardRef(function(param, forwardedRef) {
  var { __scopeDialog, ...props } = param, portalContext = usePortalContext(OVERLAY_NAME, __scopeDialog), { forceMount = portalContext.forceMount, ...overlayProps } = props, context = useDialogContext(OVERLAY_NAME, __scopeDialog), isAdapted = useAdaptIsActive();
  return !forceMount && (!context.modal || isAdapted) ? null : /* @__PURE__ */ _jsx(DialogOverlayFrame, {
    "data-state": getState(context.open),
    // We re-enable pointer-events prevented by `Dialog.Content` to allow scrolling the overlay.
    pointerEvents: context.open ? "auto" : "none",
    ...overlayProps,
    ref: forwardedRef
  });
})), CONTENT_NAME = "DialogContent", DialogContentFrame = styled(ThemeableStack, {
  name: CONTENT_NAME,
  tag: "dialog",
  variants: {
    size: {
      "...size": function(val, extras) {
        return {};
      }
    },
    unstyled: {
      false: {
        position: "relative",
        backgrounded: !0,
        padded: !0,
        radiused: !0,
        elevate: !0,
        zIndex: 1e5
      }
    }
  },
  defaultVariants: {
    size: "$true",
    unstyled: process.env.TAMAGUI_HEADLESS === "1"
  }
}), DialogContent = DialogContentFrame.extractable(/* @__PURE__ */ React.forwardRef(function(param, forwardedRef) {
  var { __scopeDialog, ...props } = param, portalContext = usePortalContext(CONTENT_NAME, __scopeDialog), { forceMount = portalContext.forceMount, ...contentProps } = props, context = useDialogContext(CONTENT_NAME, __scopeDialog), contents = context.modal ? /* @__PURE__ */ _jsx(DialogContentModal, {
    context,
    ...contentProps,
    ref: forwardedRef
  }) : /* @__PURE__ */ _jsx(DialogContentNonModal, {
    context,
    ...contentProps,
    ref: forwardedRef
  });
  return !isWeb || context.disableRemoveScroll ? contents : /* @__PURE__ */ _jsx(RemoveScroll, {
    forwardProps: !0,
    enabled: context.open,
    allowPinchZoom: context.allowPinchZoom,
    shards: [
      context.contentRef
    ],
    // causes lots of bugs on touch web on site
    removeScrollBar: !1,
    children: /* @__PURE__ */ _jsx("div", {
      "data-remove-scroll-container": !0,
      className: "_dsp_contents",
      children: contents
    })
  });
})), DialogContentModal = /* @__PURE__ */ React.forwardRef(function(param, forwardedRef) {
  var { children, context, ...props } = param, contentRef = React.useRef(null), composedRefs = useComposedRefs(forwardedRef, context.contentRef, contentRef);
  return isWeb && React.useEffect(function() {
    if (context.open) {
      var content = contentRef.current;
      if (content) return hideOthers(content);
    }
  }, [
    context.open
  ]), /* @__PURE__ */ _jsx(DialogContentImpl, {
    ...props,
    context,
    ref: composedRefs,
    // we make sure focus isn't trapped once `DialogContent` has been closed
    // (closed !== unmounted when animating out)
    trapFocus: context.open,
    disableOutsidePointerEvents: !0,
    onCloseAutoFocus: composeEventHandlers(props.onCloseAutoFocus, function(event) {
      var _context_triggerRef_current;
      event.preventDefault(), (_context_triggerRef_current = context.triggerRef.current) === null || _context_triggerRef_current === void 0 || _context_triggerRef_current.focus();
    }),
    onPointerDownOutside: composeEventHandlers(props.onPointerDownOutside, function(event) {
      var originalEvent = event.detail.originalEvent, ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === !0, isRightClick = originalEvent.button === 2 || ctrlLeftClick;
      isRightClick && event.preventDefault();
    }),
    // When focus is trapped, a `focusout` event may still happen.
    // We make sure we don't trigger our `onDismiss` in such case.
    onFocusOutside: composeEventHandlers(props.onFocusOutside, function(event) {
      return event.preventDefault();
    }),
    ...!props.unstyled && {
      outlineStyle: "none"
    },
    children
  });
}), DialogContentNonModal = /* @__PURE__ */ React.forwardRef(function(props, forwardedRef) {
  var hasInteractedOutsideRef = React.useRef(!1);
  return /* @__PURE__ */ _jsx(DialogContentImpl, {
    ...props,
    ref: forwardedRef,
    trapFocus: !1,
    disableOutsidePointerEvents: !1,
    onCloseAutoFocus: function(event) {
      var _props_onCloseAutoFocus;
      if ((_props_onCloseAutoFocus = props.onCloseAutoFocus) === null || _props_onCloseAutoFocus === void 0 || _props_onCloseAutoFocus.call(props, event), !event.defaultPrevented) {
        if (!hasInteractedOutsideRef.current) {
          var _props_context_triggerRef_current;
          (_props_context_triggerRef_current = props.context.triggerRef.current) === null || _props_context_triggerRef_current === void 0 || _props_context_triggerRef_current.focus();
        }
        event.preventDefault();
      }
      hasInteractedOutsideRef.current = !1;
    },
    onInteractOutside: function(event) {
      var _props_onInteractOutside;
      (_props_onInteractOutside = props.onInteractOutside) === null || _props_onInteractOutside === void 0 || _props_onInteractOutside.call(props, event), event.defaultPrevented || (hasInteractedOutsideRef.current = !0);
      var target = event.target, trigger = props.context.triggerRef.current;
      if (trigger instanceof HTMLElement) {
        var targetIsTrigger = trigger.contains(target);
        targetIsTrigger && event.preventDefault();
      }
    }
  });
}), DialogContentImpl = /* @__PURE__ */ React.forwardRef(function(props, forwardedRef) {
  var { __scopeDialog, trapFocus, onOpenAutoFocus, onCloseAutoFocus, disableOutsidePointerEvents, onEscapeKeyDown, onPointerDownOutside, onFocusOutside, onInteractOutside, context, ...contentProps } = props, contentRef = React.useRef(null), composedRefs = useComposedRefs(forwardedRef, contentRef), isAdapted = useAdaptIsActive();
  if (isAdapted)
    return !isWeb && !context.open ? null : /* @__PURE__ */ _jsx(DialogPortalItem, {
      children: contentProps.children
    });
  var contents = /* @__PURE__ */ _jsx(DialogContentFrame, {
    id: context.contentId,
    "aria-describedby": context.descriptionId,
    "aria-labelledby": context.titleId,
    "data-state": getState(context.open),
    ...contentProps
  });
  return isWeb ? /* @__PURE__ */ _jsxs(_Fragment, {
    children: [
      /* @__PURE__ */ _jsx(Dismissable, {
        disableOutsidePointerEvents: context.open && disableOutsidePointerEvents,
        forceUnmount: !context.open,
        onEscapeKeyDown,
        onPointerDownOutside,
        onFocusOutside,
        onInteractOutside,
        // @ts-ignore
        ref: composedRefs,
        onDismiss: function() {
          return context.onOpenChange(!1);
        },
        children: /* @__PURE__ */ _jsx(FocusScope, {
          loop: !0,
          enabled: context.open,
          trapped: trapFocus,
          onMountAutoFocus: onOpenAutoFocus,
          forceUnmount: !context.open,
          onUnmountAutoFocus: onCloseAutoFocus,
          children: contents
        })
      }),
      process.env.NODE_ENV === "development" && /* @__PURE__ */ _jsxs(_Fragment, {
        children: [
          /* @__PURE__ */ _jsx(TitleWarning, {
            titleId: context.titleId
          }),
          /* @__PURE__ */ _jsx(DescriptionWarning, {
            contentRef,
            descriptionId: context.descriptionId
          })
        ]
      })
    ]
  }) : contents;
}), DialogTitleFrame = styled(H2, {
  name: "DialogTitle"
}), DialogTitle = DialogTitleFrame.styleable(function(props, forwardedRef) {
  var { __scopeDialog, ...titleProps } = props, context = useDialogContext("DialogTitle", __scopeDialog);
  return /* @__PURE__ */ _jsx(DialogTitleFrame, {
    id: context.titleId,
    ...titleProps,
    ref: forwardedRef
  });
}), DialogDescriptionFrame = styled(Paragraph, {
  name: "DialogDescription"
}), DESCRIPTION_NAME = "DialogDescription", DialogDescription = DialogDescriptionFrame.styleable(function(props, forwardedRef) {
  var { __scopeDialog, ...descriptionProps } = props, context = useDialogContext(DESCRIPTION_NAME, __scopeDialog);
  return /* @__PURE__ */ _jsx(DialogDescriptionFrame, {
    id: context.descriptionId,
    ...descriptionProps,
    ref: forwardedRef
  });
}), CLOSE_NAME = "DialogClose", DialogCloseFrame = styled(View, {
  name: CLOSE_NAME,
  tag: "button"
}), DialogClose = DialogCloseFrame.styleable(function(props, forwardedRef) {
  var { __scopeDialog, displayWhenAdapted, ...closeProps } = props, context = useDialogContext(CLOSE_NAME, __scopeDialog, {
    warn: !1,
    fallback: {}
  }), isAdapted = useAdaptIsActive(), isInsideButton = React.useContext(ButtonNestingContext);
  return isAdapted && !displayWhenAdapted ? null : /* @__PURE__ */ _jsx(DialogCloseFrame, {
    accessibilityLabel: "Dialog Close",
    tag: isInsideButton ? "span" : "button",
    ...closeProps,
    ref: forwardedRef,
    onPress: composeEventHandlers(props.onPress, function() {
      context.onOpenChange(!1);
    })
  });
});
function getState(open) {
  return open ? "open" : "closed";
}
var TITLE_WARNING_NAME = "DialogTitleWarning", [DialogWarningProvider, useWarningContext] = createContext(TITLE_WARNING_NAME, {
  contentName: CONTENT_NAME,
  titleName: "DialogTitle",
  docsSlug: "dialog"
}), TitleWarning = function(param) {
  var { titleId } = param;
  if (process.env.NODE_ENV === "development") {
    var titleWarningContext = useWarningContext(TITLE_WARNING_NAME), MESSAGE = `\`${titleWarningContext.contentName}\` requires a \`${titleWarningContext.titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${titleWarningContext.titleName}\`, you can wrap it with our VisuallyHidden component.`;
    React.useEffect(function() {
      if (isWeb && titleId) {
        var hasTitle = document.getElementById(titleId);
        hasTitle || console.warn(MESSAGE);
      }
    }, [
      MESSAGE,
      titleId
    ]);
  }
  return null;
}, DESCRIPTION_WARNING_NAME = "DialogDescriptionWarning", DescriptionWarning = function(param) {
  var { contentRef, descriptionId } = param;
  if (process.env.NODE_ENV === "development") {
    var descriptionWarningContext = useWarningContext(DESCRIPTION_WARNING_NAME), MESSAGE = `Warning: Missing \`Description\` or \`aria-describedby={undefined}\` for {${descriptionWarningContext.contentName}}.`;
    React.useEffect(function() {
      if (isWeb) {
        var contentNode = contentRef.current;
        if (contentNode instanceof HTMLElement) {
          var describedById = contentNode.getAttribute("aria-describedby");
          if (descriptionId && describedById) {
            var hasDescription = document.getElementById(descriptionId);
            hasDescription || console.warn(MESSAGE);
          }
        }
      }
    }, [
      MESSAGE,
      contentRef,
      descriptionId
    ]);
  }
  return null;
}, Dialog = withStaticProperties(/* @__PURE__ */ React.forwardRef(function(props, ref) {
  var { __scopeDialog, children, open: openProp, defaultOpen = !1, onOpenChange, modal = !0, allowPinchZoom = !1, disableRemoveScroll = !1 } = props, baseId = React.useId(), scopeId = `scope-${baseId}`, contentId = `content-${baseId}`, titleId = `title-${baseId}`, descriptionId = `description-${baseId}`, scopeKey = __scopeDialog ? Object.keys(__scopeDialog)[0] : scopeId, adaptName = getAdaptName({
    scopeKey,
    contentId
  }), triggerRef = React.useRef(null), contentRef = React.useRef(null), [open, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen,
    onChange: onOpenChange
  }), onOpenToggle = React.useCallback(function() {
    setOpen(function(prevOpen) {
      return !prevOpen;
    });
  }, [
    setOpen
  ]), context = {
    scope: __scopeDialog,
    scopeKey,
    triggerRef,
    contentRef,
    contentId,
    titleId,
    descriptionId,
    open,
    onOpenChange: setOpen,
    onOpenToggle,
    modal,
    allowPinchZoom,
    disableRemoveScroll
  };
  return React.useImperativeHandle(ref, function() {
    return {
      open: setOpen
    };
  }, [
    setOpen
  ]), /* @__PURE__ */ _jsx(AdaptParent, {
    scope: adaptName,
    portal: {
      forwardProps: props
    },
    children: /* @__PURE__ */ _jsx(DialogProvider, {
      ...context,
      children: /* @__PURE__ */ _jsx(DialogSheetController, {
        onOpenChange: setOpen,
        __scopeDialog,
        children
      })
    })
  });
}), {
  Trigger: DialogTrigger,
  Portal: DialogPortal,
  Overlay: DialogOverlay,
  Content: DialogContent,
  Title: DialogTitle,
  Description: DialogDescription,
  Close: DialogClose,
  Sheet: Sheet.Controlled,
  Adapt
}), getAdaptName = function(param) {
  var { scopeKey, contentId } = param;
  return `${scopeKey || contentId}DialogAdapt`;
}, DialogSheetController = function(props) {
  var context = useDialogContext("DialogSheetController", props.__scopeDialog), isAdapted = useAdaptIsActive();
  return /* @__PURE__ */ _jsx(SheetController, {
    onOpenChange: function(val) {
      if (isAdapted) {
        var _props_onOpenChange;
        (_props_onOpenChange = props.onOpenChange) === null || _props_onOpenChange === void 0 || _props_onOpenChange.call(props, val);
      }
    },
    open: context.open,
    hidden: !isAdapted,
    children: props.children
  });
};
export {
  Dialog,
  DialogClose,
  DialogContent,
  DialogDescription,
  DialogOverlay,
  DialogOverlayFrame,
  DialogPortal,
  DialogPortalFrame,
  DialogTitle,
  DialogTrigger,
  DialogWarningProvider,
  createDialogScope
};
//# sourceMappingURL=Dialog.js.map
