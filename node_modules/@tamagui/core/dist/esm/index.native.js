import "@tamagui/react-native-use-responder-events";
import { Stack as WebStack, Text as WebText, View as WebView, composeEventHandlers, setupHooks } from "@tamagui/web";
import React from "react";
import { createOptimizedView } from "./createOptimizedView";
import { getBaseViews } from "./getBaseViews";
import { getRect } from "./helpers/getRect";
import { measureLayout } from "./hooks/useElementLayout";
import { usePressability } from "./vendor/Pressability";
export * from "@tamagui/web";
export * from "./reactNativeTypes";
var baseViews = getBaseViews();
setupHooks({
  getBaseViews,
  setElementProps: function(node) {
    if (node && !node.measure) {
      var _node, _node1, _node2;
      (_node = node).measure || (_node.measure = function(callback) {
        return measureLayout(node, null, callback);
      }), (_node1 = node).measureLayout || (_node1.measureLayout = function(relativeToNode, success) {
        return measureLayout(node, relativeToNode, success);
      }), (_node2 = node).measureInWindow || (_node2.measureInWindow = function(callback) {
        setTimeout(function() {
          var { height, left, top, width } = getRect(node);
          callback(left, top, width, height);
        }, 0);
      });
    }
  },
  usePropsTransform(elementType, propsIn, stateRef, willHydrate) {
    if (0) {
      var isDOM, onMoveShouldSetResponder, onMoveShouldSetResponderCapture, onResponderEnd, onResponderGrant, onResponderMove, onResponderReject, onResponderRelease, onResponderStart, onResponderTerminate, onResponderTerminationRequest, onScrollShouldSetResponder, onScrollShouldSetResponderCapture, onSelectionChangeShouldSetResponder, onSelectionChangeShouldSetResponderCapture, onStartShouldSetResponder, onStartShouldSetResponderCapture, collapsable, focusable, accessible, accessibilityDisabled, onLayout, hrefAttrs, plainDOMProps;
      if (isDOM && plainDOMProps.href && hrefAttrs)
        var download, rel, target;
    }
  },
  useEvents(viewProps, events, param, setStateShallow, staticConfig) {
    var { pseudos } = param;
    if (events && (events.onFocus && (viewProps.onFocus = events.onFocus), events.onBlur && (viewProps.onBlur = events.onBlur)), staticConfig.isInput) {
      if (events) {
        var { onPressIn, onPressOut, onPress } = events, inputEvents = {
          onPressIn,
          onPressOut: onPressOut || onPress
        };
        onPressOut && onPress && (inputEvents.onPressOut = composeEventHandlers(onPress, onPressOut)), Object.assign(viewProps, inputEvents);
      }
    } else {
      events && viewProps.hitSlop && (events.hitSlop = viewProps.hitSlop);
      var pressability = usePressability(events);
      if (events && (process.env.NODE_ENV === "development" && viewProps.debug && console.info(`Checking for press ${!!events.onPress} then applying pressability props: ${Object.keys(pressability || {})}`), events.onPress))
        for (var key in pressability) {
          var og = viewProps[key], val = pressability[key];
          viewProps[key] = og && !dontComposePressabilityKeys[key] ? composeEventHandlers(og, val) : val;
        }
    }
  },
  useChildren(elementType, children, viewProps, events, staticConfig) {
    if (process.env.NODE_ENV !== "test") {
      if (elementType === baseViews.View)
        return createOptimizedView(children, viewProps, baseViews);
      if (process.env.TAMAGUI_OPTIMIZE_NATIVE_VIEWS && elementType === baseViews.Text)
        return viewProps.children = children, /* @__PURE__ */ React.createElement("RCTText", viewProps);
    }
  }
});
var dontComposePressabilityKeys = {
  onClick: !0
}, View = WebView, Stack = WebStack, Text = WebText;
export {
  Stack,
  Text,
  View
};
//# sourceMappingURL=index.js.map
