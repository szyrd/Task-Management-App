import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { ProvideAdaptContext, useAdaptContext } from "@tamagui/adapt";
import { AnimatePresence } from "@tamagui/animate-presence";
import { useComposedRefs } from "@tamagui/compose-refs";
import { currentPlatform, isClient, isWeb, useIsomorphicLayoutEffect } from "@tamagui/constants";
import { Stack, Theme, useConfiguration, useDidFinishSSR, useEvent, useThemeName } from "@tamagui/core";
import { Portal, USE_NATIVE_PORTAL } from "@tamagui/portal";
import React, { useState } from "react";
import { Dimensions, Keyboard, PanResponder, View } from "react-native";
import { ParentSheetContext, SheetInsideSheetContext } from "./contexts";
import { resisted } from "./helpers";
import { SheetProvider } from "./SheetContext";
import { useSheetOpenState } from "./useSheetOpenState";
import { useSheetProviderProps } from "./useSheetProviderProps";
var hiddenSize = 10000.1, sheetHiddenStyleSheet = null, relativeDimensionTo = isWeb ? "window" : "screen", SheetImplementationCustom = /* @__PURE__ */ React.forwardRef(function(props, forwardedRef) {
  var parentSheet = React.useContext(ParentSheetContext), { animation, animationConfig: animationConfigProp, modal = !1, zIndex = parentSheet.zIndex + 1, moveOnKeyboardChange = !1, unmountChildrenWhenHidden = !1, portalProps, containerComponent: ContainerComponent = React.Fragment } = props, state = useSheetOpenState(props), [overlayComponent, setOverlayComponent] = React.useState(null), providerProps = useSheetProviderProps(props, state, {
    onOverlayComponent: setOverlayComponent
  }), { frameSize, setFrameSize, snapPoints, snapPointsMode, hasFit, position, setPosition, scrollBridge, screenSize, setMaxContentSize, maxSnapPoint } = providerProps, { open, controller, isHidden } = state, sheetRef = React.useRef(null), ref = useComposedRefs(forwardedRef, sheetRef, providerProps.contentRef), { animationDriver } = useConfiguration(), animationConfig = function() {
    if (animationDriver.supportsCSSVars)
      return {};
    var [animationProp, animationPropConfig] = animation ? Array.isArray(animation) ? animation : [
      animation
    ] : [];
    return animationConfigProp ?? (animationProp ? {
      ...animationDriver.animations[animationProp],
      ...animationPropConfig
    } : null);
  }(), [isShowingInnerSheet, setIsShowingInnerSheet] = React.useState(!1), shouldHideParentSheet = !isWeb && modal && isShowingInnerSheet && // if not using weird portal limitation we dont need to hide parent sheet
  USE_NATIVE_PORTAL, sheetInsideSheet = React.useContext(SheetInsideSheetContext), onInnerSheet = React.useCallback(function(hasChild) {
    setIsShowingInnerSheet(hasChild);
  }, []), positions = React.useMemo(function() {
    return snapPoints.map(function(point) {
      return getYPositions(snapPointsMode, point, screenSize, frameSize);
    });
  }, [
    screenSize,
    frameSize,
    snapPoints,
    snapPointsMode
  ]), { useAnimatedNumber, useAnimatedNumberStyle, useAnimatedNumberReaction } = animationDriver, _animationDriver_View, AnimatedView = (_animationDriver_View = animationDriver.View) !== null && _animationDriver_View !== void 0 ? _animationDriver_View : Stack;
  useIsomorphicLayoutEffect(function() {
    if (sheetInsideSheet && open)
      return sheetInsideSheet(!0), function() {
        sheetInsideSheet(!1);
      };
  }, [
    sheetInsideSheet,
    open
  ]);
  var nextParentContext = React.useMemo(function() {
    return {
      zIndex
    };
  }, [
    zIndex
  ]), isMounted = useDidFinishSSR(), startPosition = isMounted && screenSize ? screenSize : hiddenSize, animatedNumber = useAnimatedNumber(startPosition), at = React.useRef(startPosition), hasntMeasured = at.current === hiddenSize, [disableAnimation, setDisableAnimation] = useState(hasntMeasured);
  useAnimatedNumberReaction({
    value: animatedNumber,
    hostRef: sheetRef
  }, React.useCallback(function(value) {
    at.current = value, scrollBridge.paneY = value;
  }, [
    animationDriver
  ]));
  function stopSpring() {
    animatedNumber.stop(), scrollBridge.onFinishAnimate && (scrollBridge.onFinishAnimate(), scrollBridge.onFinishAnimate = void 0);
  }
  var animateTo = useEvent(function(position2) {
    if (frameSize !== 0) {
      var toValue = isHidden || position2 === -1 ? screenSize : positions[position2];
      at.current !== toValue && (at.current = toValue, stopSpring(), animatedNumber.setValue(toValue, {
        type: "spring",
        ...animationConfig
      }));
    }
  });
  useIsomorphicLayoutEffect(function() {
    if (hasntMeasured && screenSize) {
      at.current = screenSize, animatedNumber.setValue(screenSize, {
        type: "timing",
        duration: 0
      }, function() {
        setTimeout(function() {
          setDisableAnimation(!1);
        }, 10);
      });
      return;
    }
    disableAnimation || !frameSize || !screenSize || isHidden || hasntMeasured && !open || animateTo(position);
  }, [
    hasntMeasured,
    disableAnimation,
    isHidden,
    frameSize,
    screenSize,
    open,
    position
  ]);
  var _props_disableDrag, disableDrag = (_props_disableDrag = props.disableDrag) !== null && _props_disableDrag !== void 0 ? _props_disableDrag : controller == null ? void 0 : controller.disableDrag, themeName = useThemeName(), [isDragging, setIsDragging] = React.useState(!1), panResponder = React.useMemo(function() {
    if (disableDrag || !frameSize || isShowingInnerSheet) return;
    var minY = positions[0];
    scrollBridge.paneMinY = minY;
    var startY = at.current;
    function setPanning(val) {
      setIsDragging(val), isClient && (sheetHiddenStyleSheet || (sheetHiddenStyleSheet = document.createElement("style"), typeof document.head < "u" && document.head.appendChild(sheetHiddenStyleSheet)), val ? sheetHiddenStyleSheet.innerText = ":root * { user-select: none !important; -webkit-user-select: none !important; }" : sheetHiddenStyleSheet.innerText = "");
    }
    var release = function(param) {
      var { vy, dragAt } = param;
      isExternalDrag = !1, previouslyScrolling = !1, setPanning(!1);
      for (var at2 = dragAt + startY, end = at2 + frameSize * vy * 0.2, closestPoint = 0, dist = Number.POSITIVE_INFINITY, i = 0; i < positions.length; i++) {
        var position2 = positions[i], curDist = end > position2 ? end - position2 : position2 - end;
        curDist < dist && (dist = curDist, closestPoint = i);
      }
      setPosition(closestPoint), animateTo(closestPoint);
    }, finish = function(_e, state2) {
      release({
        vy: state2.vy,
        dragAt: state2.dy
      });
    }, previouslyScrolling = !1, onMoveShouldSet = function(e, param) {
      var { dy } = param;
      if (e.target === providerProps.handleRef.current)
        return !0;
      var isScrolled = scrollBridge.y !== 0, isDraggingUp = dy < 0, isNearTop = scrollBridge.paneY - 5 <= scrollBridge.paneMinY;
      return isScrolled ? (previouslyScrolling = !0, !1) : isNearTop && !isScrolled && isDraggingUp && !isWeb ? !1 : Math.abs(dy) > 5;
    }, grant = function() {
      setPanning(!0), stopSpring(), startY = at.current;
    }, isExternalDrag = !1;
    return scrollBridge.drag = function(dy) {
      isExternalDrag || (isExternalDrag = !0, grant());
      var to = dy + startY;
      animatedNumber.setValue(resisted(to, minY), {
        type: "direct"
      });
    }, scrollBridge.release = release, PanResponder.create({
      onMoveShouldSetPanResponder: onMoveShouldSet,
      onPanResponderGrant: grant,
      onPanResponderMove: function(_e, param) {
        var { dy } = param, toFull = dy + startY, to = resisted(toFull, minY);
        animatedNumber.setValue(to, {
          type: "direct"
        });
      },
      onPanResponderEnd: finish,
      onPanResponderTerminate: finish,
      onPanResponderRelease: finish
    });
  }, [
    disableDrag,
    isShowingInnerSheet,
    animateTo,
    frameSize,
    positions,
    setPosition
  ]), handleAnimationViewLayout = React.useCallback(function(e) {
    var _e_nativeEvent, next = Math.min((_e_nativeEvent = e.nativeEvent) === null || _e_nativeEvent === void 0 ? void 0 : _e_nativeEvent.layout.height, Dimensions.get(relativeDimensionTo).height);
    next && setFrameSize(next);
  }, []), handleMaxContentViewLayout = React.useCallback(function(e) {
    var _e_nativeEvent, next = Math.min((_e_nativeEvent = e.nativeEvent) === null || _e_nativeEvent === void 0 ? void 0 : _e_nativeEvent.layout.height, Dimensions.get(relativeDimensionTo).height);
    next && setMaxContentSize(next);
  }, []), animatedStyle = useAnimatedNumberStyle(animatedNumber, function(val) {
    "worklet";
    var translateY = frameSize === 0 ? hiddenSize : val;
    return {
      transform: [
        {
          translateY
        }
      ]
    };
  }), sizeBeforeKeyboard = React.useRef(null);
  React.useEffect(function() {
    if (!(isWeb || !moveOnKeyboardChange)) {
      var keyboardShowListener = Keyboard.addListener(currentPlatform === "ios" ? "keyboardWillShow" : "keyboardDidShow", function(e) {
        sizeBeforeKeyboard.current === null && (sizeBeforeKeyboard.current = isHidden || position === -1 ? screenSize : positions[position], animatedNumber.setValue(Math.max(sizeBeforeKeyboard.current - e.endCoordinates.height, 0), {
          type: "timing",
          duration: 250
        }));
      }), keyboardDidHideListener = Keyboard.addListener("keyboardDidHide", function() {
        sizeBeforeKeyboard.current !== null && (animatedNumber.setValue(sizeBeforeKeyboard.current, {
          type: "timing",
          duration: 250
        }), sizeBeforeKeyboard.current = null);
      });
      return function() {
        keyboardDidHideListener.remove(), keyboardShowListener.remove();
      };
    }
  }, [
    moveOnKeyboardChange,
    positions,
    position,
    isHidden
  ]);
  var [opacity, setOpacity] = React.useState(open ? 1 : 0);
  open && opacity === 0 && setOpacity(1), React.useEffect(function() {
    if (!open) {
      var tm = setTimeout(function() {
        setOpacity(0);
      }, 400);
      return function() {
        clearTimeout(tm);
      };
    }
  }, [
    open
  ]);
  var forcedContentHeight = hasFit ? void 0 : snapPointsMode === "percent" ? `${maxSnapPoint}${isWeb ? "dvh" : "%"}` : maxSnapPoint, contents = /* @__PURE__ */ _jsx(ParentSheetContext.Provider, {
    value: nextParentContext,
    children: /* @__PURE__ */ _jsxs(SheetProvider, {
      ...providerProps,
      children: [
        /* @__PURE__ */ _jsx(AnimatePresence, {
          custom: {
            open
          },
          children: shouldHideParentSheet || !open ? null : overlayComponent
        }),
        snapPointsMode !== "percent" && /* @__PURE__ */ _jsx(View, {
          style: {
            opacity: 0,
            position: "absolute",
            top: 0,
            left: 0,
            right: 0,
            bottom: 0,
            pointerEvents: "none"
          },
          onLayout: handleMaxContentViewLayout
        }),
        /* @__PURE__ */ _jsx(AnimatedView, {
          ref,
          ...panResponder == null ? void 0 : panResponder.panHandlers,
          onLayout: handleAnimationViewLayout,
          ...!isDragging && {
            // @ts-ignore for CSS driver this is necessary to attach the transition
            animation: disableAnimation ? null : animation
          },
          // @ts-ignore
          disableClassName: !0,
          style: [
            {
              position: "absolute",
              zIndex,
              width: "100%",
              height: forcedContentHeight,
              minHeight: forcedContentHeight,
              opacity: shouldHideParentSheet ? 0 : opacity,
              ...(shouldHideParentSheet || !open) && {
                pointerEvents: "none"
              }
            },
            animatedStyle
          ],
          children: (
            /* <AdaptProvider>{props.children}</AdaptProvider> */
            props.children
          )
        })
      ]
    })
  });
  if (!USE_NATIVE_PORTAL) {
    var adaptContext = useAdaptContext();
    contents = /* @__PURE__ */ _jsx(ProvideAdaptContext, {
      ...adaptContext,
      children: contents
    });
  }
  var shouldMountChildren = unmountChildrenWhenHidden ? !!opacity : !0;
  if (modal) {
    var modalContents = /* @__PURE__ */ _jsx(Portal, {
      stackZIndex: zIndex,
      ...portalProps,
      children: shouldMountChildren && /* @__PURE__ */ _jsx(ContainerComponent, {
        children: /* @__PURE__ */ _jsx(Theme, {
          forceClassName: !0,
          name: themeName,
          children: contents
        })
      })
    });
    return isWeb ? modalContents : /* @__PURE__ */ _jsx(SheetInsideSheetContext.Provider, {
      value: onInnerSheet,
      children: modalContents
    });
  }
  return contents;
});
function getYPositions(mode, point, screenSize, frameSize) {
  if (!screenSize || !frameSize) return 0;
  if (mode === "mixed") {
    if (typeof point == "number")
      return screenSize - Math.min(screenSize, Math.max(0, point));
    if (point === "fit")
      return screenSize - Math.min(screenSize, frameSize);
    if (point.endsWith("%")) {
      var pct = Math.min(100, Math.max(0, Number(point.slice(0, -1)))) / 100;
      if (Number.isNaN(pct))
        return console.warn("Invalid snapPoint percentage string"), 0;
      var next = Math.round(screenSize - pct * screenSize);
      return next;
    }
    return console.warn("Invalid snapPoint unknown value"), 0;
  }
  if (mode === "fit")
    return point === 0 ? screenSize : screenSize - Math.min(screenSize, frameSize);
  if (mode === "constant" && typeof point == "number")
    return screenSize - Math.min(screenSize, Math.max(0, point));
  var pct1 = Math.min(100, Math.max(0, Number(point))) / 100;
  return Number.isNaN(pct1) ? (console.warn("Invalid snapPoint percentage"), 0) : Math.round(screenSize - pct1 * screenSize);
}
export {
  SheetImplementationCustom
};
//# sourceMappingURL=SheetImplementationCustom.js.map
