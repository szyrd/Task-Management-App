import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import React from "react";
import { AdaptParentContext } from "@tamagui/adapt";
import { AnimatePresence } from "@tamagui/animate-presence";
import { useComposedRefs } from "@tamagui/compose-refs";
import { currentPlatform, isWeb, useIsomorphicLayoutEffect } from "@tamagui/constants";
import { getConfig, Stack, Theme, themeable, useConfiguration, useEvent, useThemeName } from "@tamagui/core";
import { Portal } from "@tamagui/portal";
import { useKeyboardVisible } from "@tamagui/use-keyboard-visible";
import { Dimensions, Keyboard, PanResponder, View } from "react-native";
import { SHEET_HIDDEN_STYLESHEET } from "./constants.native.mjs";
import { ParentSheetContext, SheetInsideSheetContext } from "./contexts.native.mjs";
import { resisted } from "./helpers.native.mjs";
import { SheetProvider } from "./SheetContext.native.mjs";
import { useSheetOpenState } from "./useSheetOpenState.native.mjs";
import { useSheetProviderProps } from "./useSheetProviderProps.native.mjs";
var hiddenSize = 10000.1,
  SheetImplementationCustom = themeable(/* @__PURE__ */React.forwardRef(function (props, forwardedRef) {
    var parentSheet = React.useContext(ParentSheetContext),
      {
        animation,
        animationConfig: animationConfigProp,
        modal = !1,
        zIndex = parentSheet.zIndex + 1,
        moveOnKeyboardChange = !1,
        unmountChildrenWhenHidden = !1,
        portalProps,
        containerComponent: ContainerComponent = React.Fragment
      } = props,
      keyboardIsVisible = useKeyboardVisible(),
      state = useSheetOpenState(props),
      [overlayComponent, setOverlayComponent] = React.useState(null),
      providerProps = useSheetProviderProps(props, state, {
        onOverlayComponent: setOverlayComponent
      }),
      {
        frameSize,
        setFrameSize,
        snapPoints,
        snapPointsMode,
        hasFit,
        position,
        setPosition,
        scrollBridge,
        screenSize,
        setMaxContentSize,
        maxSnapPoint
      } = providerProps,
      {
        open,
        controller,
        isHidden
      } = state,
      sheetRef = React.useRef(null),
      ref = useComposedRefs(forwardedRef, sheetRef),
      animationConfig = function () {
        var [animationProp, animationPropConfig] = animation ? Array.isArray(animation) ? animation : [animation] : [];
        return animationConfigProp ?? (animationProp ? {
          ...getConfig().animations.animations[animationProp],
          ...animationPropConfig
        } : null);
      }(),
      [isShowingInnerSheet, setIsShowingInnerSheet] = React.useState(!1),
      shouldHideParentSheet = !isWeb && modal && isShowingInnerSheet,
      parentSheetContext = React.useContext(SheetInsideSheetContext),
      onInnerSheet = React.useCallback(function (hasChild) {
        setIsShowingInnerSheet(hasChild);
      }, []),
      positions = React.useMemo(function () {
        return snapPoints.map(function (point) {
          return getYPositions(snapPointsMode, point, screenSize, frameSize);
        });
      }, [screenSize, frameSize, snapPoints, snapPointsMode]),
      {
        animationDriver
      } = useConfiguration(),
      {
        useAnimatedNumber,
        useAnimatedNumberStyle,
        useAnimatedNumberReaction
      } = animationDriver,
      _animationDriver_View,
      AnimatedView = (_animationDriver_View = animationDriver.View) !== null && _animationDriver_View !== void 0 ? _animationDriver_View : Stack;
    useIsomorphicLayoutEffect(function () {
      if (parentSheetContext && open) return parentSheetContext(!0), function () {
        parentSheetContext(!1);
      };
    }, [parentSheetContext, open]);
    var nextParentContext = React.useMemo(function () {
        return {
          zIndex
        };
      }, [zIndex]),
      animatedNumber = useAnimatedNumber(hiddenSize),
      at = React.useRef(hiddenSize);
    useAnimatedNumberReaction({
      value: animatedNumber,
      hostRef: sheetRef
    }, React.useCallback(function (value) {
      at.current = value, scrollBridge.paneY = value;
    }, [animationDriver]));
    function stopSpring() {
      animatedNumber.stop(), scrollBridge.onFinishAnimate && (scrollBridge.onFinishAnimate(), scrollBridge.onFinishAnimate = void 0);
    }
    var hasntMeasured = at.current === hiddenSize,
      animateTo = useEvent(function (position2) {
        if (frameSize !== 0) {
          var toValue = isHidden || position2 === -1 ? screenSize : positions[position2];
          if (at.current !== toValue) {
            if (at.current = toValue, stopSpring(), hasntMeasured || isHidden) {
              animatedNumber.setValue(screenSize, {
                type: "timing",
                duration: 0
              }, function () {
                isHidden || (toValue = positions[position2], at.current = toValue, animatedNumber.setValue(toValue, {
                  type: "spring",
                  ...animationConfig
                }));
              });
              return;
            }
            animatedNumber.setValue(toValue, {
              type: "spring",
              ...animationConfig
            });
          }
        }
      });
    useIsomorphicLayoutEffect(function () {
      screenSize && hasntMeasured && animatedNumber.setValue(screenSize, {
        type: "timing",
        duration: 0
      });
    }, [hasntMeasured, screenSize]), useIsomorphicLayoutEffect(function () {
      !frameSize || !screenSize || isHidden || hasntMeasured && !open || animateTo(position);
    }, [isHidden, frameSize, screenSize, open, position]);
    var _props_disableDrag,
      disableDrag = (_props_disableDrag = props.disableDrag) !== null && _props_disableDrag !== void 0 ? _props_disableDrag : controller?.disableDrag,
      themeName = useThemeName(),
      [isDragging, setIsDragging] = React.useState(!1),
      panResponder = React.useMemo(function () {
        if (disableDrag || !frameSize || isShowingInnerSheet) return;
        var minY = positions[0];
        scrollBridge.paneMinY = minY;
        var startY = at.current;
        function setPanning(val) {
          setIsDragging(val), SHEET_HIDDEN_STYLESHEET && (val ? SHEET_HIDDEN_STYLESHEET.innerText = ":root * { user-select: none !important; -webkit-user-select: none !important; }" : SHEET_HIDDEN_STYLESHEET.innerText = "");
        }
        var release = function (param) {
            var {
              vy,
              dragAt
            } = param;
            isExternalDrag = !1, previouslyScrolling = !1, setPanning(!1);
            for (var at2 = dragAt + startY, end = at2 + frameSize * vy * 0.2, closestPoint = 0, dist = Number.POSITIVE_INFINITY, i = 0; i < positions.length; i++) {
              var position2 = positions[i],
                curDist = end > position2 ? end - position2 : position2 - end;
              curDist < dist && (dist = curDist, closestPoint = i);
            }
            setPosition(closestPoint), animateTo(closestPoint);
          },
          finish = function (_e, state2) {
            release({
              vy: state2.vy,
              dragAt: state2.dy
            });
          },
          previouslyScrolling = !1,
          onMoveShouldSet = function (e, param) {
            var {
              dy
            } = param;
            if (e.target === providerProps.handleRef.current) return !0;
            var isScrolled = scrollBridge.y !== 0,
              isDraggingUp = dy < 0,
              isNearTop = scrollBridge.paneY - 5 <= scrollBridge.paneMinY;
            return isScrolled ? (previouslyScrolling = !0, !1) : isNearTop && !isScrolled && isDraggingUp && !isWeb ? !1 : Math.abs(dy) > 5;
          },
          grant = function () {
            setPanning(!0), stopSpring(), startY = at.current;
          },
          isExternalDrag = !1;
        return scrollBridge.drag = function (dy) {
          isExternalDrag || (isExternalDrag = !0, grant());
          var to = dy + startY;
          animatedNumber.setValue(resisted(to, minY), {
            type: "direct"
          });
        }, scrollBridge.release = release, PanResponder.create({
          onMoveShouldSetPanResponder: onMoveShouldSet,
          onPanResponderGrant: grant,
          onPanResponderMove: function (_e, param) {
            var {
                dy
              } = param,
              toFull = dy + startY,
              to = resisted(toFull, minY);
            animatedNumber.setValue(to, {
              type: "direct"
            });
          },
          onPanResponderEnd: finish,
          onPanResponderTerminate: finish,
          onPanResponderRelease: finish
        });
      }, [disableDrag, isShowingInnerSheet, animateTo, frameSize, positions, setPosition]),
      handleAnimationViewLayout = React.useCallback(function (e) {
        var _e_nativeEvent,
          next = Math.min((_e_nativeEvent = e.nativeEvent) === null || _e_nativeEvent === void 0 ? void 0 : _e_nativeEvent.layout.height, Dimensions.get("screen").height);
        next && setFrameSize(next);
      }, [keyboardIsVisible]),
      handleMaxContentViewLayout = React.useCallback(function (e) {
        var _e_nativeEvent,
          next = Math.min((_e_nativeEvent = e.nativeEvent) === null || _e_nativeEvent === void 0 ? void 0 : _e_nativeEvent.layout.height, Dimensions.get("screen").height);
        next && setMaxContentSize(next);
      }, [keyboardIsVisible]),
      animatedStyle = useAnimatedNumberStyle(animatedNumber, function (val) {
        "worklet";

        var translateY = frameSize === 0 ? hiddenSize : val;
        return {
          transform: [{
            translateY
          }]
        };
      }),
      sizeBeforeKeyboard = React.useRef(null);
    React.useEffect(function () {
      if (!(isWeb || !moveOnKeyboardChange)) {
        var keyboardShowListener = Keyboard.addListener(currentPlatform === "ios" ? "keyboardWillShow" : "keyboardDidShow", function (e) {
            sizeBeforeKeyboard.current === null && (sizeBeforeKeyboard.current = isHidden || position === -1 ? screenSize : positions[position], animatedNumber.setValue(Math.max(sizeBeforeKeyboard.current - e.endCoordinates.height, 0), {
              type: "timing",
              duration: 250
            }));
          }),
          keyboardDidHideListener = Keyboard.addListener("keyboardDidHide", function () {
            sizeBeforeKeyboard.current !== null && (animatedNumber.setValue(sizeBeforeKeyboard.current, {
              type: "timing",
              duration: 250
            }), sizeBeforeKeyboard.current = null);
          });
        return function () {
          keyboardDidHideListener.remove(), keyboardShowListener.remove();
        };
      }
    }, [moveOnKeyboardChange, positions, position, isHidden]);
    var [opacity, setOpacity] = React.useState(open ? 1 : 0);
    open && opacity === 0 && setOpacity(1), React.useEffect(function () {
      if (!open) {
        var tm = setTimeout(function () {
          setOpacity(0);
        }, 400);
        return function () {
          clearTimeout(tm);
        };
      }
    }, [open]);
    var forcedContentHeight = hasFit ? void 0 : snapPointsMode === "percent" ? `${maxSnapPoint}${isWeb ? "dvh" : "%"}` : maxSnapPoint,
      contents = /* @__PURE__ */_jsx(ParentSheetContext.Provider, {
        value: nextParentContext,
        children: /* @__PURE__ */_jsxs(SheetProvider, {
          ...providerProps,
          children: [/* @__PURE__ */_jsx(AnimatePresence, {
            custom: {
              open
            },
            children: shouldHideParentSheet || !open ? null : overlayComponent
          }), snapPointsMode !== "percent" && /* @__PURE__ */_jsx(View, {
            style: {
              opacity: 0,
              position: "absolute",
              top: 0,
              left: 0,
              right: 0,
              bottom: 0,
              pointerEvents: "none"
            },
            onLayout: handleMaxContentViewLayout
          }), /* @__PURE__ */_jsx(AnimatedView, {
            ref,
            ...panResponder?.panHandlers,
            onLayout: handleAnimationViewLayout,
            ...(!isDragging && {
              // @ts-ignore for CSS driver this is necessary to attach the transition
              animation
            }),
            // @ts-ignore
            disableClassName: !0,
            style: [{
              position: "absolute",
              zIndex,
              width: "100%",
              height: forcedContentHeight,
              minHeight: forcedContentHeight,
              opacity,
              ...((shouldHideParentSheet || !open) && {
                pointerEvents: "none"
              })
            }, animatedStyle],
            children: props.children
          })]
        })
      }),
      adaptContext = React.useContext(AdaptParentContext),
      shouldMountChildren = !!(opacity || !unmountChildrenWhenHidden);
    if (modal) {
      var modalContents = /* @__PURE__ */_jsx(Portal, {
        zIndex,
        ...portalProps,
        children: shouldMountChildren && /* @__PURE__ */_jsx(ContainerComponent, {
          children: /* @__PURE__ */_jsx(Theme, {
            forceClassName: !0,
            name: themeName,
            children: /* @__PURE__ */_jsx(AdaptParentContext.Provider, {
              value: adaptContext,
              children: contents
            })
          })
        })
      });
      return isWeb ? modalContents : /* @__PURE__ */_jsx(SheetInsideSheetContext.Provider, {
        value: onInnerSheet,
        children: modalContents
      });
    }
    return contents;
  }));
function getYPositions(mode, point, screenSize, frameSize) {
  if (!screenSize || !frameSize) return 0;
  if (mode === "mixed") {
    if (typeof point == "number") return screenSize - Math.min(screenSize, Math.max(0, point));
    if (point === "fit") return screenSize - Math.min(screenSize, frameSize);
    if (point.endsWith("%")) {
      var pct = Math.min(100, Math.max(0, Number(point.slice(0, -1)))) / 100;
      if (Number.isNaN(pct)) return console.warn("Invalid snapPoint percentage string"), 0;
      var next = Math.round(screenSize - pct * screenSize);
      return next;
    }
    return console.warn("Invalid snapPoint unknown value"), 0;
  }
  if (mode === "fit") return point === 0 ? screenSize : screenSize - Math.min(screenSize, frameSize);
  if (mode === "constant" && typeof point == "number") return screenSize - Math.min(screenSize, Math.max(0, point));
  var pct1 = Math.min(100, Math.max(0, Number(point))) / 100;
  return Number.isNaN(pct1) ? (console.warn("Invalid snapPoint percentage"), 0) : Math.round(screenSize - pct1 * screenSize);
}
export { SheetImplementationCustom };
//# sourceMappingURL=SheetImplementationCustom.native.mjs.map
