"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf, __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: !0 });
}, __copyProps = (to, from, except, desc) => {
  if (from && typeof from == "object" || typeof from == "function")
    for (let key of __getOwnPropNames(from))
      !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: !0 }) : target,
  mod
)), __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: !0 }), mod);
var SheetImplementationCustom_exports = {};
__export(SheetImplementationCustom_exports, {
  SheetImplementationCustom: () => SheetImplementationCustom
});
module.exports = __toCommonJS(SheetImplementationCustom_exports);
var import_jsx_runtime = require("react/jsx-runtime"), import_adapt = require("@tamagui/adapt"), import_animate_presence = require("@tamagui/animate-presence"), import_compose_refs = require("@tamagui/compose-refs"), import_constants = require("@tamagui/constants"), import_core = require("@tamagui/core"), import_portal = require("@tamagui/portal"), import_react = __toESM(require("react")), import_react_native = require("react-native"), import_contexts = require("./contexts"), import_helpers = require("./helpers"), import_SheetContext = require("./SheetContext"), import_useSheetOpenState = require("./useSheetOpenState"), import_useSheetProviderProps = require("./useSheetProviderProps"), hiddenSize = 10000.1, sheetHiddenStyleSheet = null, relativeDimensionTo = import_constants.isWeb ? "window" : "screen", SheetImplementationCustom = /* @__PURE__ */ import_react.default.forwardRef(function(props, forwardedRef) {
  var parentSheet = import_react.default.useContext(import_contexts.ParentSheetContext), { animation, animationConfig: animationConfigProp, modal = !1, zIndex = parentSheet.zIndex + 1, moveOnKeyboardChange = !1, unmountChildrenWhenHidden = !1, portalProps, containerComponent: ContainerComponent = import_react.default.Fragment } = props, state = (0, import_useSheetOpenState.useSheetOpenState)(props), [overlayComponent, setOverlayComponent] = import_react.default.useState(null), providerProps = (0, import_useSheetProviderProps.useSheetProviderProps)(props, state, {
    onOverlayComponent: setOverlayComponent
  }), { frameSize, setFrameSize, snapPoints, snapPointsMode, hasFit, position, setPosition, scrollBridge, screenSize, setMaxContentSize, maxSnapPoint } = providerProps, { open, controller, isHidden } = state, sheetRef = import_react.default.useRef(null), ref = (0, import_compose_refs.useComposedRefs)(forwardedRef, sheetRef, providerProps.contentRef), { animationDriver } = (0, import_core.useConfiguration)(), animationConfig = function() {
    if (animationDriver.supportsCSSVars)
      return {};
    var [animationProp, animationPropConfig] = animation ? Array.isArray(animation) ? animation : [
      animation
    ] : [];
    return animationConfigProp ?? (animationProp ? {
      ...animationDriver.animations[animationProp],
      ...animationPropConfig
    } : null);
  }(), [isShowingInnerSheet, setIsShowingInnerSheet] = import_react.default.useState(!1), shouldHideParentSheet = !import_constants.isWeb && modal && isShowingInnerSheet && // if not using weird portal limitation we dont need to hide parent sheet
  import_portal.USE_NATIVE_PORTAL, sheetInsideSheet = import_react.default.useContext(import_contexts.SheetInsideSheetContext), onInnerSheet = import_react.default.useCallback(function(hasChild) {
    setIsShowingInnerSheet(hasChild);
  }, []), positions = import_react.default.useMemo(function() {
    return snapPoints.map(function(point) {
      return getYPositions(snapPointsMode, point, screenSize, frameSize);
    });
  }, [
    screenSize,
    frameSize,
    snapPoints,
    snapPointsMode
  ]), { useAnimatedNumber, useAnimatedNumberStyle, useAnimatedNumberReaction } = animationDriver, _animationDriver_View, AnimatedView = (_animationDriver_View = animationDriver.View) !== null && _animationDriver_View !== void 0 ? _animationDriver_View : import_core.Stack;
  (0, import_constants.useIsomorphicLayoutEffect)(function() {
    if (sheetInsideSheet && open)
      return sheetInsideSheet(!0), function() {
        sheetInsideSheet(!1);
      };
  }, [
    sheetInsideSheet,
    open
  ]);
  var nextParentContext = import_react.default.useMemo(function() {
    return {
      zIndex
    };
  }, [
    zIndex
  ]), isMounted = (0, import_core.useDidFinishSSR)(), startPosition = isMounted && screenSize ? screenSize : hiddenSize, animatedNumber = useAnimatedNumber(startPosition), at = import_react.default.useRef(startPosition), hasntMeasured = at.current === hiddenSize, [disableAnimation, setDisableAnimation] = (0, import_react.useState)(hasntMeasured);
  useAnimatedNumberReaction({
    value: animatedNumber,
    hostRef: sheetRef
  }, import_react.default.useCallback(function(value) {
    at.current = value, scrollBridge.paneY = value;
  }, [
    animationDriver
  ]));
  function stopSpring() {
    animatedNumber.stop(), scrollBridge.onFinishAnimate && (scrollBridge.onFinishAnimate(), scrollBridge.onFinishAnimate = void 0);
  }
  var animateTo = (0, import_core.useEvent)(function(position2) {
    if (frameSize !== 0) {
      var toValue = isHidden || position2 === -1 ? screenSize : positions[position2];
      at.current !== toValue && (at.current = toValue, stopSpring(), animatedNumber.setValue(toValue, {
        type: "spring",
        ...animationConfig
      }));
    }
  });
  (0, import_constants.useIsomorphicLayoutEffect)(function() {
    if (hasntMeasured && screenSize) {
      at.current = screenSize, animatedNumber.setValue(screenSize, {
        type: "timing",
        duration: 0
      }, function() {
        setTimeout(function() {
          setDisableAnimation(!1);
        }, 10);
      });
      return;
    }
    disableAnimation || !frameSize || !screenSize || isHidden || hasntMeasured && !open || animateTo(position);
  }, [
    hasntMeasured,
    disableAnimation,
    isHidden,
    frameSize,
    screenSize,
    open,
    position
  ]);
  var _props_disableDrag, disableDrag = (_props_disableDrag = props.disableDrag) !== null && _props_disableDrag !== void 0 ? _props_disableDrag : controller == null ? void 0 : controller.disableDrag, themeName = (0, import_core.useThemeName)(), [isDragging, setIsDragging] = import_react.default.useState(!1), panResponder = import_react.default.useMemo(function() {
    if (disableDrag || !frameSize || isShowingInnerSheet) return;
    var minY = positions[0];
    scrollBridge.paneMinY = minY;
    var startY = at.current;
    function setPanning(val) {
      setIsDragging(val), import_constants.isClient && (sheetHiddenStyleSheet || (sheetHiddenStyleSheet = document.createElement("style"), typeof document.head < "u" && document.head.appendChild(sheetHiddenStyleSheet)), val ? sheetHiddenStyleSheet.innerText = ":root * { user-select: none !important; -webkit-user-select: none !important; }" : sheetHiddenStyleSheet.innerText = "");
    }
    var release = function(param) {
      var { vy, dragAt } = param;
      isExternalDrag = !1, previouslyScrolling = !1, setPanning(!1);
      for (var at2 = dragAt + startY, end = at2 + frameSize * vy * 0.2, closestPoint = 0, dist = Number.POSITIVE_INFINITY, i = 0; i < positions.length; i++) {
        var position2 = positions[i], curDist = end > position2 ? end - position2 : position2 - end;
        curDist < dist && (dist = curDist, closestPoint = i);
      }
      setPosition(closestPoint), animateTo(closestPoint);
    }, finish = function(_e, state2) {
      release({
        vy: state2.vy,
        dragAt: state2.dy
      });
    }, previouslyScrolling = !1, onMoveShouldSet = function(e, param) {
      var { dy } = param;
      if (e.target === providerProps.handleRef.current)
        return !0;
      var isScrolled = scrollBridge.y !== 0, isDraggingUp = dy < 0, isNearTop = scrollBridge.paneY - 5 <= scrollBridge.paneMinY;
      return isScrolled ? (previouslyScrolling = !0, !1) : isNearTop && !isScrolled && isDraggingUp && !import_constants.isWeb ? !1 : Math.abs(dy) > 5;
    }, grant = function() {
      setPanning(!0), stopSpring(), startY = at.current;
    }, isExternalDrag = !1;
    return scrollBridge.drag = function(dy) {
      isExternalDrag || (isExternalDrag = !0, grant());
      var to = dy + startY;
      animatedNumber.setValue((0, import_helpers.resisted)(to, minY), {
        type: "direct"
      });
    }, scrollBridge.release = release, import_react_native.PanResponder.create({
      onMoveShouldSetPanResponder: onMoveShouldSet,
      onPanResponderGrant: grant,
      onPanResponderMove: function(_e, param) {
        var { dy } = param, toFull = dy + startY, to = (0, import_helpers.resisted)(toFull, minY);
        animatedNumber.setValue(to, {
          type: "direct"
        });
      },
      onPanResponderEnd: finish,
      onPanResponderTerminate: finish,
      onPanResponderRelease: finish
    });
  }, [
    disableDrag,
    isShowingInnerSheet,
    animateTo,
    frameSize,
    positions,
    setPosition
  ]), handleAnimationViewLayout = import_react.default.useCallback(function(e) {
    var _e_nativeEvent, next = Math.min((_e_nativeEvent = e.nativeEvent) === null || _e_nativeEvent === void 0 ? void 0 : _e_nativeEvent.layout.height, import_react_native.Dimensions.get(relativeDimensionTo).height);
    next && setFrameSize(next);
  }, []), handleMaxContentViewLayout = import_react.default.useCallback(function(e) {
    var _e_nativeEvent, next = Math.min((_e_nativeEvent = e.nativeEvent) === null || _e_nativeEvent === void 0 ? void 0 : _e_nativeEvent.layout.height, import_react_native.Dimensions.get(relativeDimensionTo).height);
    next && setMaxContentSize(next);
  }, []), animatedStyle = useAnimatedNumberStyle(animatedNumber, function(val) {
    "worklet";
    var translateY = frameSize === 0 ? hiddenSize : val;
    return {
      transform: [
        {
          translateY
        }
      ]
    };
  }), sizeBeforeKeyboard = import_react.default.useRef(null);
  import_react.default.useEffect(function() {
    if (!(import_constants.isWeb || !moveOnKeyboardChange)) {
      var keyboardShowListener = import_react_native.Keyboard.addListener(import_constants.currentPlatform === "ios" ? "keyboardWillShow" : "keyboardDidShow", function(e) {
        sizeBeforeKeyboard.current === null && (sizeBeforeKeyboard.current = isHidden || position === -1 ? screenSize : positions[position], animatedNumber.setValue(Math.max(sizeBeforeKeyboard.current - e.endCoordinates.height, 0), {
          type: "timing",
          duration: 250
        }));
      }), keyboardDidHideListener = import_react_native.Keyboard.addListener("keyboardDidHide", function() {
        sizeBeforeKeyboard.current !== null && (animatedNumber.setValue(sizeBeforeKeyboard.current, {
          type: "timing",
          duration: 250
        }), sizeBeforeKeyboard.current = null);
      });
      return function() {
        keyboardDidHideListener.remove(), keyboardShowListener.remove();
      };
    }
  }, [
    moveOnKeyboardChange,
    positions,
    position,
    isHidden
  ]);
  var [opacity, setOpacity] = import_react.default.useState(open ? 1 : 0);
  open && opacity === 0 && setOpacity(1), import_react.default.useEffect(function() {
    if (!open) {
      var tm = setTimeout(function() {
        setOpacity(0);
      }, 400);
      return function() {
        clearTimeout(tm);
      };
    }
  }, [
    open
  ]);
  var forcedContentHeight = hasFit ? void 0 : snapPointsMode === "percent" ? `${maxSnapPoint}${import_constants.isWeb ? "dvh" : "%"}` : maxSnapPoint, contents = /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_contexts.ParentSheetContext.Provider, {
    value: nextParentContext,
    children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_SheetContext.SheetProvider, {
      ...providerProps,
      children: [
        /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_animate_presence.AnimatePresence, {
          custom: {
            open
          },
          children: shouldHideParentSheet || !open ? null : overlayComponent
        }),
        snapPointsMode !== "percent" && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_react_native.View, {
          style: {
            opacity: 0,
            position: "absolute",
            top: 0,
            left: 0,
            right: 0,
            bottom: 0,
            pointerEvents: "none"
          },
          onLayout: handleMaxContentViewLayout
        }),
        /* @__PURE__ */ (0, import_jsx_runtime.jsx)(AnimatedView, {
          ref,
          ...panResponder == null ? void 0 : panResponder.panHandlers,
          onLayout: handleAnimationViewLayout,
          ...!isDragging && {
            // @ts-ignore for CSS driver this is necessary to attach the transition
            animation: disableAnimation ? null : animation
          },
          // @ts-ignore
          disableClassName: !0,
          style: [
            {
              position: "absolute",
              zIndex,
              width: "100%",
              height: forcedContentHeight,
              minHeight: forcedContentHeight,
              opacity: shouldHideParentSheet ? 0 : opacity,
              ...(shouldHideParentSheet || !open) && {
                pointerEvents: "none"
              }
            },
            animatedStyle
          ],
          children: (
            /* <AdaptProvider>{props.children}</AdaptProvider> */
            props.children
          )
        })
      ]
    })
  });
  if (!import_portal.USE_NATIVE_PORTAL) {
    var adaptContext = (0, import_adapt.useAdaptContext)();
    contents = /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_adapt.ProvideAdaptContext, {
      ...adaptContext,
      children: contents
    });
  }
  var shouldMountChildren = unmountChildrenWhenHidden ? !!opacity : !0;
  if (modal) {
    var modalContents = /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_portal.Portal, {
      stackZIndex: zIndex,
      ...portalProps,
      children: shouldMountChildren && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ContainerComponent, {
        children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_core.Theme, {
          forceClassName: !0,
          name: themeName,
          children: contents
        })
      })
    });
    return import_constants.isWeb ? modalContents : /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_contexts.SheetInsideSheetContext.Provider, {
      value: onInnerSheet,
      children: modalContents
    });
  }
  return contents;
});
function getYPositions(mode, point, screenSize, frameSize) {
  if (!screenSize || !frameSize) return 0;
  if (mode === "mixed") {
    if (typeof point == "number")
      return screenSize - Math.min(screenSize, Math.max(0, point));
    if (point === "fit")
      return screenSize - Math.min(screenSize, frameSize);
    if (point.endsWith("%")) {
      var pct = Math.min(100, Math.max(0, Number(point.slice(0, -1)))) / 100;
      if (Number.isNaN(pct))
        return console.warn("Invalid snapPoint percentage string"), 0;
      var next = Math.round(screenSize - pct * screenSize);
      return next;
    }
    return console.warn("Invalid snapPoint unknown value"), 0;
  }
  if (mode === "fit")
    return point === 0 ? screenSize : screenSize - Math.min(screenSize, frameSize);
  if (mode === "constant" && typeof point == "number")
    return screenSize - Math.min(screenSize, Math.max(0, point));
  var pct1 = Math.min(100, Math.max(0, Number(point))) / 100;
  return Number.isNaN(pct1) ? (console.warn("Invalid snapPoint percentage"), 0) : Math.round(screenSize - pct1 * screenSize);
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  SheetImplementationCustom
});
//# sourceMappingURL=SheetImplementationCustom.js.map
