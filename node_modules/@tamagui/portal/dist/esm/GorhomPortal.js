import { isWeb } from "@tamagui/constants";
import { startTransition } from "@tamagui/start-transition";
import React, {
  createContext,
  memo,
  useCallback,
  useContext,
  useEffect,
  useMemo,
  useReducer
} from "react";
import { allPortalHosts, portalListeners } from "./constants";
import { Fragment, jsx, jsxs } from "react/jsx-runtime";
var ACTIONS = /* @__PURE__ */ ((ACTIONS2) => (ACTIONS2[ACTIONS2.REGISTER_HOST = 0] = "REGISTER_HOST", ACTIONS2[ACTIONS2.DEREGISTER_HOST = 1] = "DEREGISTER_HOST", ACTIONS2[ACTIONS2.ADD_UPDATE_PORTAL = 2] = "ADD_UPDATE_PORTAL", ACTIONS2[ACTIONS2.REMOVE_PORTAL = 3] = "REMOVE_PORTAL", ACTIONS2))(ACTIONS || {});
const INITIAL_STATE = {};
const registerHost = (state, hostName) => (hostName in state || (state[hostName] = []), state), deregisterHost = (state, hostName) => (delete state[hostName], state), addUpdatePortal = (state, hostName, portalName, node) => {
  hostName in state || (state = registerHost(state, hostName));
  const index = state[hostName].findIndex((item) => item.name === portalName);
  return index !== -1 ? state[hostName][index].node = node : state[hostName].push({
    name: portalName,
    node
  }), state;
}, removePortal = (state, hostName, portalName) => {
  if (!(hostName in state))
    return console.info(
      `Failed to remove portal '${portalName}', '${hostName}' was not registered!`
    ), state;
  const index = state[hostName].findIndex((item) => item.name === portalName);
  return index !== -1 && state[hostName].splice(index, 1), state;
}, reducer = (state, action) => {
  const { type } = action;
  switch (type) {
    case 0 /* REGISTER_HOST */:
      return registerHost({ ...state }, action.hostName);
    case 1 /* DEREGISTER_HOST */:
      return deregisterHost({ ...state }, action.hostName);
    case 2 /* ADD_UPDATE_PORTAL */:
      return addUpdatePortal(
        { ...state },
        action.hostName,
        action.portalName,
        action.node
      );
    case 3 /* REMOVE_PORTAL */:
      return removePortal(
        { ...state },
        action.hostName,
        action.portalName
      );
    default:
      return state;
  }
}, PortalStateContext = createContext(null), PortalDispatchContext = createContext(null), usePortalState = (hostName) => {
  const state = useContext(PortalStateContext);
  if (state === null)
    throw new Error(
      "'PortalStateContext' cannot be null, please add 'PortalProvider' to the root component."
    );
  return state[hostName] || [];
}, usePortal = (hostName = "root") => {
  const dispatch = useContext(PortalDispatchContext);
  if (dispatch === null)
    throw new Error(
      "'PortalDispatchContext' cannot be null, please add 'PortalProvider' to the root component."
    );
  const registerHost2 = useCallback(() => {
    dispatch({
      type: 0 /* REGISTER_HOST */,
      hostName
    });
  }, []), deregisterHost2 = useCallback(() => {
    dispatch({
      type: 1 /* DEREGISTER_HOST */,
      hostName
    });
  }, []), addUpdatePortal2 = useCallback((name, node) => {
    dispatch({
      type: 2 /* ADD_UPDATE_PORTAL */,
      hostName,
      portalName: name,
      node
    });
  }, []), removePortal2 = useCallback((name) => {
    dispatch({
      type: 3 /* REMOVE_PORTAL */,
      hostName,
      portalName: name
    });
  }, []);
  return {
    registerHost: registerHost2,
    deregisterHost: deregisterHost2,
    addPortal: addUpdatePortal2,
    updatePortal: addUpdatePortal2,
    removePortal: removePortal2
  };
}, PortalProviderComponent = ({
  rootHostName = "root",
  shouldAddRootHost = !0,
  children
}) => {
  const [state, dispatch] = useReducer(reducer, INITIAL_STATE), transitionDispatch = useMemo(() => (value) => {
    startTransition(() => {
      dispatch(value);
    });
  }, [dispatch]);
  return /* @__PURE__ */ jsx(PortalDispatchContext.Provider, { value: transitionDispatch, children: /* @__PURE__ */ jsxs(PortalStateContext.Provider, { value: state, children: [
    children,
    shouldAddRootHost && /* @__PURE__ */ jsx(PortalHost, { name: rootHostName })
  ] }) });
}, PortalProvider = memo(PortalProviderComponent);
PortalProvider.displayName = "PortalProvider";
const defaultRenderer = (children) => /* @__PURE__ */ jsx(Fragment, { children }), PortalHost = memo(function(props) {
  return isWeb ? /* @__PURE__ */ jsx(PortalHostWeb, { ...props }) : /* @__PURE__ */ jsx(PortalHostNonNative, { ...props });
});
function PortalHostWeb(props) {
  return /* @__PURE__ */ jsx(
    "div",
    {
      style: {
        display: "contents"
      },
      ref: (node) => {
        node ? (allPortalHosts.set(props.name, node), portalListeners[props.name]?.forEach((x) => x(node))) : allPortalHosts.delete(props.name);
      }
    }
  );
}
function PortalHostNonNative(props) {
  const { name, forwardProps, render = defaultRenderer } = props, state = usePortalState(name), { registerHost: registerHost2, deregisterHost: deregisterHost2 } = usePortal(props.name);
  return useEffect(() => {
    if (!(typeof window > "u"))
      return registerHost2(), () => {
        deregisterHost2();
      };
  }, []), render(
    forwardProps ? state.map((item) => {
      let next = item.node;
      const { children, ...restForwardProps } = forwardProps;
      return forwardProps ? React.Children.map(next, (child) => React.isValidElement(child) ? React.cloneElement(child, { key: child.key, ...restForwardProps }) : child) : next;
    }) : state.map((item) => item.node)
  );
}
export {
  ACTIONS,
  INITIAL_STATE,
  PortalHost,
  PortalProvider,
  usePortal
};
//# sourceMappingURL=GorhomPortal.js.map
